{
  "name": "filterpy",
  "summary": "Kalman filtering and optimal estimation library",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "filterpy::chunk_0",
      "text": "FilterPy - Kalman filters and other optimal and non-optimal estimation filters in Python.\n-----------------------------------------------------------------------------------------\n\n.. image:: https://img.shields.io/pypi/v/filterpy.svg\n\n**NOTE**: Imminent drop of support of Python 2.7, 3.4. See section below for details.\n\nThis library provides Kalman filtering and various related optimal and\nnon-optimal filtering software written in Python. It contains Kalman\nfilters, Extended Kalman filters, Unscented Kalman filters, Kalman\nsmoothers, Least Squares filters, fading memory filters, g-h filters,\ndiscrete Bayes, and more.\n\nThis is code I am developing in conjunction with my book Kalman and\nBayesian Filter in Python, which you can read/download at\n\nMy aim is largely pedalogical - I opt for clear code that matches the\nequations in the relevant texts on a 1-to-1 basis, even when that has a\nperformance cost. There are places where this tradeoff is unclear - for\nexample, I find it somewhat clearer to write a small set of equations\nusing linear algebra, but numpy's overhead on small matrices makes it\nrun slower than writing each equation out by hand. Furthermore, books\nsuch Zarchan present the written out form, not the linear algebra form.\nIt is hard for me to choose which presentation is 'clearer' - it depends\non the audience. In that case I usually opt for the faster implementation.\n\nI use NumPy and SciPy for all of the computations. I have experimented\nwith Numba and it yields impressive speed ups with minimal costs, but I \nam not convinced that I want to add that requirement to my project. It \nis still on my list of things to figure out, however.\n\nSphinx generated documentation lives at http://filterpy.readthedocs.org/.\nGeneration is triggered by git when I do a check in, so this will always\nbe bleeding edge development version - it will often be ahead of the\nreleased version.\n\nPlan for dropping Python 2.7 support\n------------------------------------\n\nI haven't finalized my decision on this, but NumPy is dropping\nPython 2.7 support in December 2018. I will certainly drop Python\n2.7 support by then; I will probably do it much sooner.\n\nAt the moment FilterPy is on version 1.x. I plan to fork the project\nto version 2.0, and support only Python 3.5+. The 1.x version \nwill still be available, but I will not support it. If I add something\namazing to 2.0 and someone really begs, I might backport it; more\nlikely I would accept a pull request with the feature backported\nto 1.x. But to be honest I don't forsee this happening.",
      "word_count": 407
    },
    {
      "chunk_id": "filterpy::chunk_1",
      "text": "Why 3.5+, and not 3.4+? 3.5 introduced the matrix multiply symbol,\nand I want my code to take advantage of it. Plus, to be honest,\nI'm being selfish. I don't want to spend my life supporting this\npackage, and moving as far into the present as possible means\na few extra years before the Python version I choose becomes\nhopelessly dated and a liability. I recognize this makes people\nrunning the default Python in their linux distribution more\npainful. All I can say is I did not decide to do the Python\n3 fork, and I don't have the time to support the bifurcation\nany longer.\n\nI am making edits to the package now in support of my book;\nonce those are done I'll probably create the 2.0 branch. \nI'm contemplating a SLAM addition to the book, and am not\nsure if I will do this in 3.5+ only or not.\n\nInstallation\n------------\n\nThe most general installation is just to use pip, which should come with\nany modern Python distribution.\n\n.. image:: https://img.shields.io/pypi/v/filterpy.svg\n::\n\nIf you prefer to download the source yourself\n\n::\n\nIf you use Anaconda, you can install from the conda-forge channel. You\nwill need to add the conda-forge channel if you haven't already done so:\n\n::\nand then install with:\n\n::\nAnd, if you want to install from the bleeding edge git version\n\n::\n\nNote: I make no guarantees that everything works if you install from here.\nI'm the only developer, and so I don't worry about dev/release branches and\nthe like. Unless I fix a bug for you and tell you to get this version because\nI haven't made a new release yet, I strongly advise not installing from git.\n\nBasic use\n---------\n\nFull documentation is at\n\nFirst, import the filters and helper functions.\n\n.. code-block:: python\n\nNow, create the filter\n\n.. code-block:: python\n\nInitialize the filter's matrices.\n\n.. code-block:: python\n\nFinally, run the filter.\n\n.. code-block:: python\n\nSorry, that is the extent of the documentation here. However, the library\nis broken up into subdirectories: gh, kalman, memory, leastsq, and so on.\nEach subdirectory contains python files relating to that form of filter.\nThe functions and methods contain pretty good docstrings on use.\n\nMy book https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/\nuses this library, and is the place to go if you are trying to learn\nabout Kalman filtering and/or this library. These two are not exactly in \nsync - my normal development cycle is to add files here, test them, figure \nout how to present them pedalogically, then write the appropriate section\nor chapter in the book. So there is code here that is not discussed\nyet in the book.\n\nRequirements\n------------\n\nThis library uses NumPy, SciPy, Matplotlib, and Python.\n\nI haven't extensively tested backwards compatibility - I use the\nAnaconda distribution, and so I am on Python 3.6 and 2.7.14, along with\nwhatever version of NumPy, SciPy, and matplotlib they provide. But I am\nusing pretty basic Python - numpy.array, maybe a list comprehension in\nmy tests.",
      "word_count": 498
    },
    {
      "chunk_id": "filterpy::chunk_2",
      "text": "I import from **__future__** to ensure the code works in Python 2 and 3.\n\nTesting\n-------\n\nAll tests are written to work with py.test. Just type ``py.test`` at the\ncommand line.\n\nAs explained above, the tests are not robust. I'm still at the stage\nwhere visual plots are the best way to see how things are working.\nApologies, but I think it is a sound choice for development. It is easy\nfor a filter to perform within theoretical limits (which we can write a\nnon-visual test for) yet be 'off' in some way. The code itself contains\ntests in the form of asserts and properties that ensure that arrays are\nof the proper dimension, etc.\n\nReferences\n----------\n\nI use three main texts as my refererence, though I do own the majority\nof the Kalman filtering literature. First is Paul Zarchan's\n'Fundamentals of Kalman Filtering: A Practical Approach'. I think it by\nfar the best Kalman filtering book out there if you are interested in\npractical applications more than writing a thesis. The second book I use\nis Eli Brookner's 'Tracking and Kalman Filtering Made Easy'. This is an\nastonishingly good book; its first chapter is actually readable by the\nlayperson! Brookner starts from the g-h filter, and shows how all other\nfilters - the Kalman filter, least squares, fading memory, etc., all\nderive from the g-h filter. It greatly simplifies many aspects of\nanalysis and/or intuitive understanding of your problem. In contrast,\nZarchan starts from least squares, and then moves on to Kalman\nfiltering. I find that he downplays the predict-update aspect of the\nalgorithms, but he has a wealth of worked examples and comparisons\nbetween different methods. I think both viewpoints are needed, and so I\ncan't imagine discarding one book. Brookner also focuses on issues that\nare ignored in other books - track initialization, detecting and\ndiscarding noise, tracking multiple objects, an so on.\n\nI said three books. I also like and use Bar-Shalom's Estimation with\nApplications to Tracking and Navigation. Much more mathematical than the\nprevious two books, I would not recommend it as a first text unless you\nalready have a background in control theory or optimal estimation. Once\nyou have that experience, this book is a gem. Every sentence is crystal\nclear, his language is precise, but each abstract mathematical statement\nis followed with something like \"and this means...\".\n\nLicense\n-------\n\nThe MIT License (MIT)\n\nCopyright (c) 2015 Roger R. Labbe Jr\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.",
      "word_count": 493
    },
    {
      "chunk_id": "filterpy::chunk_3",
      "text": "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.TION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
      "word_count": 100
    }
  ]
}