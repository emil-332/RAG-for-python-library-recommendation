{
  "name": "numpy-quaternion",
  "summary": "Add a quaternion dtype to NumPy",
  "language": "python",
  "tags": [
    "math",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "numpy-quaternion::chunk_0",
      "text": "Quaternions in numpy\n\nThis Python module adds a quaternion dtype to NumPy.\n\nThe code was originally based on [code by Martin\nLing](https://github.com/martinling/numpy_quaternion) (which he wrote\nwith help from Mark Wiebe), but was rewritten with ideas from\n[rational](https://github.com/numpy/numpy-dtypes/tree/master/npytypes/rational)\nto work with newer python versions (and to fix a few bugs), and\n*greatly* expands the applications of quaternions.\n\nSee also the pure-python package\n[quaternionic](https://github.com/moble/quaternionic).\n\nQuickstart\n\nor\n\nOptionally add `--user` after `install` in the second command if\nyou're not using a python environment — though you should start.\n\nInstallation\n\nAssuming you use `conda` to manage your python installation (which is\ncurrently the preferred choice for science and engineering with\npython), you can install this package simply as\n\nIf you prefer to use `pip`, you can instead do\n\n(See [here](https://snarky.ca/why-you-should-use-python-m-pip/) for a\nveteran python core contributor's explanation of why you should always\nuse `python -m pip` instead of just `pip` or `pip3`.)  The `--upgrade\n--force-reinstall` options are not always necessary, but will ensure\nthat pip will update numpy if it has to.\n\nIf you refuse to use `conda`, you might want to install inside your\nhome directory without root privileges.  (Conda does this by default\nanyway.)  This is done by adding `--user` to the above command:\n\nNote that pip will attempt to compile the code — which requires a\nworking `C` compiler.\n\nFinally, there's also the fully manual option of just downloading the\ncode, changing to the code directory, and running\n\nThis should work regardless of the installation method, as long as you\nhave a compiler hanging around.\n\nBasic usage\n\nThe full documentation can be found on [Read the\nDocs](https://quaternion.readthedocs.io/), and most functions have\ndocstrings that should explain the relevant points.  The following are\nmostly for the purposes of example.\n\nNote that this package represents a quaternion as a scalar, followed\nby the `x` component of the vector part, followed by `y`, followed by\n`z`.  These components can be accessed directly:\n\nHowever, this only works on an individual `quaternion`; for arrays it\nis better to use \"vectorized\" operations like `as_float_array`.\n\nThe following ufuncs are implemented (which means they run fast on\nnumpy arrays):\n\nQuaternion components are stored as double-precision floating point\nnumbers — `float`s, in python language, or `float64` in more precise\nnumpy language.  Numpy arrays with `dtype=quaternion` can be accessed\nas arrays of doubles without any (slow, memory-consuming) copying of\ndata; rather, a `view` of the exact same memory space can be created\nwithin a microsecond, regardless of the shape or size of the\nquaternion array.\n\nComparison operations follow the same lexicographic ordering as\ntuples.\n\nThe unary tests isnan and isinf return true if they would return true\nfor any individual component; isfinite returns true if it would return\ntrue for all components.\n\nReal types may be cast to quaternions, giving quaternions with zero\nfor all three imaginary components. Complex types may also be cast to\nquaternions, with their single imaginary component becoming the first\nimaginary component of the quaternion. Quaternions may not be cast to\nreal or complex types.",
      "word_count": 497
    },
    {
      "chunk_id": "numpy-quaternion::chunk_1",
      "text": "Several array-conversion functions are also included.  For example, to\nconvert an Nx4 array of floats to an N-dimensional array of\nquaternions, use `as_quat_array`:\n\n[Note that quaternions are printed with full precision, unlike floats,\nwhich is why you see extra digits above.  But the actual data is\nidentical in the two cases.]  To convert an N-dimensional array of\nquaternions to an Nx4 array of floats, use `as_float_array`:\n\nIt is also possible to convert a quaternion to or from a 3x3 array of\nfloats representing a rotation matrix, or an array of N quaternions to\nor from an Nx3x3 array of floats representing N rotation matrices,\nusing `as_rotation_matrix` and `from_rotation_matrix`.  Similar\nconversions are possible for rotation vectors using\n`as_rotation_vector` and `from_rotation_vector`, and for spherical\ncoordinates using `as_spherical_coords` and `from_spherical_coords`.\nFinally, it is possible to derive the Euler angles from a quaternion\nusing `as_euler_angles`, or create a quaternion from Euler angles\nusing `from_euler_angles` — though be aware that Euler angles are\nbasically the worst things\never.[1](#1-euler-angles-are-awful) Before you complain\nabout those functions using something other than your favorite\nconventions, please read [this\npage](https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible).\n\nDependencies\n\nWith the standard installation methods, hopefully you won't need to\nworry about dependencies directly.  But in case you do, here's what\nyou need to know.\n\nThe basic requirements for this code are reasonably current versions\nof `python` and `numpy`.  In particular, `python` versions 3.10\nthrough 3.13 are routinely tested.  Because of its crucial dependence\non `numpy`, this package can only support versions of `python` that\nare directly supported by `numpy` — which limits support to releases\nfrom the past few years.  Old versions of `python` will work with\n*older* versions of this package, which are still available from PyPI\nand conda-forge.  Some older versions of `python` may still work with\nnewer versions of this package, but your mileage may vary.\n\nHowever, certain advanced functions in this package (including\n`squad`, `mean_rotor_in_intrinsic_metric`,\n`integrate_angular_velocity`, and related functions) require\n[`scipy`](http://scipy.org/) and can automatically use\n[`numba`](http://numba.pydata.org/).  `Scipy` is a standard python\npackage for scientific computation, and implements interfaces to C and\nFortran codes for optimization (among other things) need for finding\nmean and optimal rotors.  `Numba` uses [LLVM](http://llvm.org/) to\ncompile python code to machine code, accelerating many numerical\nfunctions by factors of anywhere from 2 to 2000.  It is *possible* to\nrun all the code without `numba`, but these particular functions can\nbe anywhere from 4 to 400 times slower without it.\n\nBoth `scipy` and `numba` can be installed with `pip` or `conda`.\nHowever, because `conda` is specifically geared toward scientific\npython, it is generally more robust for these more complicated\npackages.  In fact, the main\n[`anaconda`](https://www.anaconda.com/products/individual) package\ncomes with both `numba` and `scipy`.  If you prefer the smaller\ndownload size of [`miniconda`](http://conda.pydata.org/miniconda.html)\n(which comes with minimal extras), you'll also have to run this\ncommand:\n\nBug reports and feature requests",
      "word_count": 466
    },
    {
      "chunk_id": "numpy-quaternion::chunk_2",
      "text": "Bug reports and feature requests are entirely welcome (with [very few\nexceptions](https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible#opening-issues-and-pull-requests)).\nThe best way to do this is to open an [issue on this code's github\npage](https://github.com/moble/quaternion/issues).  For bug reports,\nplease try to include a minimal working example demonstrating the\nproblem.\n\n[Pull requests](https://help.github.com/articles/using-pull-requests/)\nare also entirely welcome, of course, if you have an idea where the\ncode is going wrong, or have an idea for a new feature that you know\nhow to implement.\n\nThis code is routinely tested on recent versions of both python (3.8\nthough 3.11) and numpy (>=1.13).  But the test coverage is not\nnecessarily as complete as it could be, so bugs may certainly be\npresent, especially in the higher-level functions like\n`mean_rotor_...`.\n\nAcknowledgments\n\nThis code is, of course, hosted on github.  Because it is an\nopen-source project, the hosting is free, and all the wonderful\nfeatures of github are available, including free wiki space and web\npage hosting, pull requests, a nice interface to the git logs, etc.\nGithub user Hannes Ovrén (hovren) pointed out some errors in a\nprevious version of this code and suggested some nice utility\nfunctions for rotation matrices, etc.  Github user Stijn van Drongelen\n(rhymoid) contributed some code that makes compilation work with\nMSVC++.  Github user Jon Long (longjon) has provided some elegant\ncontributions to substantially improve several tricky parts of this\ncode.  Rebecca Turner (9999years) and Leo Stein (duetosymmetry) did\nall the work in getting the documentation onto [Read the\nDocs](https://quaternion.readthedocs.io/).\n\nEvery change in this code is [automatically\ntested](https://github.com/moble/quaternion/actions) on Github\nActions.  The code is downloaded and installed fresh each time, and\nthen tested, on each of the different supported versions of python, on\neach of the supported platforms.  This ensures that no change I make\nto the code breaks either installation or any of the features that I\nhave written tests for.  Github Actions also automatically builds the\n`pip` versions of the code hosted on\n[pypi](https://pypi.python.org/pypi/numpy-quaternion).  Conda-forge\nalso uses Github Actions to build [the conda/mamba\nversion](https://github.com/conda-forge/quaternion-feedstock) hosted\non [anaconda.org](https://anaconda.org/conda-forge/quaternion).  These\nare all free services for open-source projects like this one.\n\nThe work of creating this code was supported in part by the Sherman\nFairchild Foundation and by NSF Grants No. PHY-1306125 and\nAST-1333129.\n\n---\n\n1 Euler angles are awful\n\nEuler angles are pretty much [the worst things\never](https://moble.github.io/spherical_functions/#euler-angles) and it\nmakes me feel bad even supporting them.  Quaternions are faster, more\naccurate, basically free of singularities, more intuitive, and\ngenerally easier to understand.  You can work entirely without Euler\nangles (I certainly do).  You absolutely never need them.  But if\nyou really can't give them up, they are mildly supported.",
      "word_count": 433
    }
  ],
  "usage_description": "This library is used to extend NumPy with quaternion data type support, enabling developers to natively represent and perform operations on quaternions within their numerical computations. With numpy-quaternion, developers can now seamlessly integrate quaternion-based math into their applications."
}