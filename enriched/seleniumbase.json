{
  "name": "seleniumbase",
  "summary": "A complete web automation framework for end-to-end testing.",
  "language": "python",
  "tags": [
    "cli",
    "dev",
    "math",
    "ml",
    "ui",
    "visualization",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "seleniumbase::chunk_0",
      "text": "SeleniumBase\n\nAutomate, test, and scrape the web — on your own terms.\n\nStart |\n Features |\n️ Options |\n Examples |\n Scripts |\n Mobile\n\nThe API |\n  SyntaxFormats |\n Recorder |\n Dashboard |\n Locale\n\n️ GUI |\n TestPage |\n UC Mode |\n CDP Mode |\n Charts  |\n️ Farm\n\n️ How |\n Migration |\n Stealthy Playwright |\n MasterQA |\n Tours\n\nCI/CD |\n️ JSMgr |\n Translator |\n️ Presenter |\n️ Visual |\n️ CPlans\n\nSeleniumBase is a browser automation framework that empowers software teams to innovate faster and handle modern web challenges with ease. With stealth options like CDP Mode, you'll avoid the usual restrictions imposed by websites deploying bot-detection services.\n\n--------\n\nLearn from [**over 200 examples** in the **SeleniumBase/examples/** folder](https://github.com/seleniumbase/SeleniumBase/tree/master/examples).\n\nStealth modes: UC Mode and CDP Mode can bypass bot-detection, solve CAPTCHAs, and call advanced methods from the Chrome Devtools Protocol.\n\nℹ️ Many examples run with raw python, although some use Syntax Formats that expect pytest (a Python unit-testing framework included with SeleniumBase that can discover, collect, and run tests automatically).\n\n--------\n\nThis script performs a Google Search using SeleniumBase UC Mode + CDP Mode:SeleniumBase/examples/raw_google.py (Results are saved as PDF, HTML, and PNG)\n\n> `python raw_google.py`\n\n--------\n\nHere's a script that bypasses Cloudflare's challenge page with UC Mode + CDP Mode: SeleniumBase/examples/cdp_mode/raw_gitlab.py\n\nThere's also SeleniumBase's \"Pure CDP Mode\", which doesn't use WebDriver or Selenium at all: SeleniumBase/examples/cdp_mode/raw_cdp_gitlab.py\n\n--------\n\nHere's SeleniumBase/examples/test_get_swag.py, which tests an e-commerce site:\n\n> `pytest test_get_swag.py`\n\n> (The default browser is ``--chrome`` if not set.)\n\n--------\n\nHere's SeleniumBase/examples/test_coffee_cart.py, which verifies an e-commerce site:\n\n> (--demo mode slows down tests and highlights actions)\n\n--------\n\nHere's SeleniumBase/examples/test_demo_site.py, which covers several actions:\n\n> Easy to type, click, select, toggle, drag & drop, and more.\n\n(For more examples, see the SeleniumBase/examples/ folder.)\n\n--------\n\nExplore the README:\n\nGet Started / Installation\nBasic Example / Usage\nCommon Test Methods\nFun Facts / Learn More\nDemo Mode / Debugging\nCommand-line Options\nDirectory Configuration\nSeleniumBase Dashboard\nGenerating Test Reports\n\n--------\n\n▶️ How is SeleniumBase different from raw Selenium? (click to expand)\n\nSeleniumBase is a Python framework for browser automation and testing. SeleniumBase uses Selenium/WebDriver APIs and incorporates test-runners such as pytest, pynose, and behave to provide organized structure, test discovery, test execution, test state (eg. passed, failed, or skipped), and command-line options for changing default settings (eg. browser selection). With raw Selenium, you would need to set up your own options-parser for configuring tests from the command-line.\n\nSeleniumBase's driver manager gives you more control over automatic driver downloads. (Use --driver-version=VER with your pytest run command to specify the version.) By default, SeleniumBase will download a driver version that matches your major browser version if not set.\n\nSeleniumBase automatically detects between CSS Selectors and XPath, which means you don't need to specify the type of selector in your commands (but optionally you could).",
      "word_count": 468
    },
    {
      "chunk_id": "seleniumbase::chunk_1",
      "text": "SeleniumBase methods often perform multiple actions in a single method call. For example, self.type(selector, text) does the following:1. Waits for the element to be visible.2. Waits for the element to be interactive.3. Clears the text field.4. Types in the new text.5. Presses Enter/Submit if the text ends in \"\\n\".With raw Selenium, those actions require multiple method calls.\n\nSeleniumBase uses default timeout values when not set:\n self.click(\"button\")\nWith raw Selenium, methods would fail instantly (by default) if an element needed more time to load:\n self.driver.find_element(by=\"css selector\", value=\"button\").click()\n(Reliable code is better than unreliable code.)\n\nSeleniumBase lets you change the explicit timeout values of methods:\n self.click(\"button\", timeout=10)\nWith raw Selenium, that requires more code:\n WebDriverWait(driver, 10).until(EC.element_to_be_clickable(\"css selector\", \"button\")).click()\n(Simple code is better than complex code.)\n\nSeleniumBase gives you clean error output when a test fails. With raw Selenium, error messages can get very messy.\n\nSeleniumBase gives you the option to generate a dashboard and reports for tests. It also saves screenshots from failing tests to the ./latest_logs/ folder. Raw Selenium does not have these options out-of-the-box.\n\nSeleniumBase includes desktop GUI apps for running tests, such as SeleniumBase Commander for pytest and SeleniumBase Behave GUI for behave.\n\nSeleniumBase has its own Recorder / Test Generator for creating tests from manual browser actions.\n\nSeleniumBase comes with test case management software, (\"CasePlans\"), for organizing tests and step descriptions.\n\nSeleniumBase includes tools for building data apps, (\"ChartMaker\"), which can generate JavaScript from Python.\n\n--------\n\nLearn about different ways of writing tests:\n\nHere's test_simple_login.py, which uses BaseCase class inheritance, and runs with pytest or pynose. (Use self.driver to access Selenium's raw driver.)\n\nHere's raw_login_sb.py, which uses the SB Context Manager. Runs with pure python. (Use sb.driver to access Selenium's raw driver.)\n\nHere's raw_login_driver.py, which uses the Driver Manager. Runs with pure python. (The driver is an improved version of Selenium's raw driver, with more methods.)\n\n--------\n\nSet up Python & Git:\n\nAdd Python and Git to your System PATH.\n\nUsing a Python virtual env is recommended.\n\nInstall SeleniumBase:\n\n**You can install ``seleniumbase`` from [PyPI](https://pypi.org/project/seleniumbase/) or [GitHub](https://github.com/seleniumbase/SeleniumBase):**\n\n**How to install ``seleniumbase`` from PyPI:**\n\n* (Add ``--upgrade`` OR ``-U`` to upgrade SeleniumBase.)\n* (Add ``--force-reinstall`` to upgrade indirect packages.)\n\n**How to install ``seleniumbase`` from a GitHub clone:**\n\n**How to upgrade an existing install from a GitHub clone:**\n\n**Type ``seleniumbase`` or ``sbase`` to verify that SeleniumBase was installed successfully:**\n\nDownloading webdrivers:\n\nSeleniumBase automatically downloads webdrivers as needed, such as ``chromedriver``.\n\n▶️ Here's sample output from a chromedriver download. (click to expand)\n\nBasic Example / Usage:\n\nIf you've cloned SeleniumBase, you can run tests from the [examples/](https://github.com/seleniumbase/SeleniumBase/tree/master/examples) folder.\n\nHere's my_first_test.py:\n\nHere's the full code for my_first_test.py:\n\n* By default, **[CSS Selectors](https://www.w3schools.com/cssref/css_selectors.asp)** are used for finding page elements.\n* If you're new to CSS Selectors, games like [CSS Diner](http://flukeout.github.io/) can help you learn.\n* For more reading, [here's an advanced guide on CSS attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n\nHere are some common SeleniumBase methods:\n\nFor the complete list of SeleniumBase methods, see: Method Summary\n\nFun Facts / Learn More:",
      "word_count": 494
    },
    {
      "chunk_id": "seleniumbase::chunk_2",
      "text": "SeleniumBase automatically handles common WebDriver actions such as launching web browsers before tests, saving screenshots during failures, and closing web browsers after tests.\n\nSeleniumBase lets you customize tests via command-line options.\n\nSeleniumBase uses simple syntax for commands. Example:\n\nMost SeleniumBase scripts can be run with pytest, pynose, or pure python. Not all test runners can run all test formats. For example, tests that use the ``sb`` pytest fixture can only be run with ``pytest``. (See Syntax Formats) There's also a Gherkin test format that runs with behave.\n\npytest includes automatic test discovery. If you don't specify a specific file or folder to run, pytest will automatically search through all subdirectories for tests to run based on the following criteria:\n\n* Python files that start with ``test_`` or end with ``_test.py``.\n* Python methods that start with ``test_``.\n\nWith a SeleniumBase [pytest.ini](https://github.com/seleniumbase/SeleniumBase/blob/master/examples/pytest.ini) file present, you can modify default discovery settings. The Python class name can be anything because ``seleniumbase.BaseCase`` inherits ``unittest.TestCase`` to trigger autodiscovery.\n\nYou can do a pre-flight check to see which tests would get discovered by pytest before the actual run:\n\nYou can be more specific when calling pytest or pynose on a file:\n\nNo More Flaky Tests! SeleniumBase methods automatically wait for page elements to finish loading before interacting with them (up to a timeout limit). This means you no longer need random time.sleep() statements in your scripts.\n\nSeleniumBase supports all major browsers and operating systems:\nBrowsers: Chrome, Edge, Firefox, and Safari.\nSystems: Linux/Ubuntu, macOS, and Windows.\n\nSeleniumBase works on all popular CI/CD platforms:\n\nSeleniumBase includes an automated/manual hybrid solution called MasterQA to speed up manual testing with automation while manual testers handle validation.\n\nSeleniumBase supports running tests while offline (assuming webdrivers have previously been downloaded when online).\n\nFor a full list of SeleniumBase features, Click Here.\n\nDemo Mode / Debugging:\n\nDemo Mode helps you see what a test is doing. If a test is moving too fast for your eyes, run it in Demo Mode to pause the browser briefly between actions, highlight page elements being acted on, and display assertions:\n\n``time.sleep(seconds)`` can be used to make a test wait at a specific spot:\n\n**Debug Mode** with Python's built-in **[pdb](https://docs.python.org/3/library/pdb.html)** library helps you debug tests:\n\n> (**``pdb``** commands: ``n``, ``c``, ``s``, ``u``, ``d`` => ``next``, ``continue``, ``step``, ``up``, ``down``)\n\nTo pause an active test that throws an exception or error, (*and keep the browser window open while **Debug Mode** begins in the console*), add **``--pdb``** as a ``pytest`` option:\n\nTo start tests in Debug Mode, add **``--trace``** as a ``pytest`` option:\n\nCommand-line Options:\n\nHere are some useful command-line options that come with pytest:\n\nSeleniumBase provides additional pytest command-line options for tests:\n\n(See the full list of command-line option definitions **[here](https://github.com/seleniumbase/SeleniumBase/blob/master/seleniumbase/plugins/pytest_plugin.py)**. For detailed examples of command-line options, see **[customizing_test_runs.md](https://github.com/seleniumbase/SeleniumBase/blob/master/help_docs/customizing_test_runs.md)**)\n\n--------",
      "word_count": 462
    },
    {
      "chunk_id": "seleniumbase::chunk_3",
      "text": "During test failures, logs and screenshots from the most recent test run will get saved to the ``latest_logs/`` folder. Those logs will get moved to ``archived_logs/`` if you add --archive_logs to command-line options, or have ``ARCHIVE_EXISTING_LOGS`` set to True in [settings.py](https://github.com/seleniumbase/SeleniumBase/blob/master/seleniumbase/config/settings.py), otherwise log files with be cleaned up at the start of the next test run. The ``test_suite.py`` collection contains tests that fail on purpose so that you can see how logging works.\n\nAn easy way to override seleniumbase/config/settings.py is by using a custom settings file.\nHere's the command-line option to add to tests: (See [examples/custom_settings.py](https://github.com/seleniumbase/SeleniumBase/blob/master/examples/custom_settings.py))\n``--settings_file=custom_settings.py``\n(Settings include default timeout values, a two-factor auth key, DB credentials, S3 credentials, and other important settings used by tests.)\n\nTo pass additional data from the command-line to tests, add ``--data=\"ANY STRING\"``.\nInside your tests, you can use ``self.data`` to access that.\n\nDirectory Configuration:\n\nWhen running tests with **``pytest``**, you'll want a copy of **[pytest.ini](https://github.com/seleniumbase/SeleniumBase/blob/master/pytest.ini)** in your root folders. When running tests with **``pynose``**, you'll want a copy of **[setup.cfg](https://github.com/seleniumbase/SeleniumBase/blob/master/setup.cfg)** in your root folders. These files specify default configuration details for tests. Test folders should also include a blank **[__init__.py](https://github.com/seleniumbase/SeleniumBase/blob/master/examples/offline_examples/__init__.py)** file to allow your test files to import other files from that folder.\n\n``sbase mkdir DIR`` creates a folder with config files and sample tests:\n\n> That new folder will have these files:\n\nProTip™: You can also create a boilerplate folder without any sample tests in it by adding ``-b`` or ``--basic`` to the ``sbase mkdir`` command:\n\n> That new folder will have these files:\n\nOf those files, the ``pytest.ini`` config file is the most important, followed by a blank ``__init__.py`` file. There's also a ``setup.cfg`` file (for pynose). Finally, the ``requirements.txt`` file can be used to help you install seleniumbase into your environments (if it's not already installed).\n\n--------\n\nLog files from failed tests:\n\nLet's try an example of a test that fails:\n\nYou can run it from the ``examples/`` folder like this:\n\nYou'll notice that a logs folder, ``./latest_logs/``, was created to hold information (and screenshots) about the failing test. During test runs, past results get moved to the archived_logs folder if you have ARCHIVE_EXISTING_LOGS set to True in [settings.py](https://github.com/seleniumbase/SeleniumBase/blob/master/seleniumbase/config/settings.py), or if your run tests with ``--archive-logs``. If you choose not to archive existing logs, they will be deleted and replaced by the logs of the latest test run.\n\n--------\n\nSeleniumBase Dashboard:\n\nThe ``--dashboard`` option for pytest generates a SeleniumBase Dashboard located at ``dashboard.html``, which updates automatically as tests run and produce results. Example:\n\nAdditionally, you can host your own SeleniumBase Dashboard Server on a port of your choice. Here's an example of that using Python's ``http.server``:\n\nNow you can navigate to ``http://localhost:1948/dashboard.html`` in order to view the dashboard as a web app. This requires two different terminal windows: one for running the server, and another for running the tests, which should be run from the same directory. (Use Ctrl+C to stop the http server.)\n\nHere's a full example of what the SeleniumBase Dashboard may look like:\n\n--------\n\nGenerating Test Reports:",
      "word_count": 500
    },
    {
      "chunk_id": "seleniumbase::chunk_4",
      "text": "pytest HTML Reports:\n\nUsing ``--html=report.html`` gives you a fancy report of the name specified after your test suite completes.\n\nWhen combining pytest html reports with SeleniumBase Dashboard usage, the pie chart from the Dashboard will get added to the html report. Additionally, if you set the html report URL to be the same as the Dashboard URL when also using the dashboard, (example: ``--dashboard --html=dashboard.html``), then the Dashboard will become an advanced html report when all the tests complete.\n\nHere's an example of an upgraded html report:\n\nIf viewing pytest html reports in [Jenkins](https://www.jenkins.io/), you may need to [configure Jenkins settings](https://stackoverflow.com/a/46197356/7058266) for the html to render correctly. This is due to [Jenkins CSP changes](https://www.jenkins.io/doc/book/system-administration/security/configuring-content-security-policy/).\n\nYou can also use ``--junit-xml=report.xml`` to get an xml report instead. Jenkins can use this file to display better reporting for your tests.\n\npynose Reports:\n\nThe ``--report`` option gives you a fancy report after your test suite completes.\n\n(NOTE: You can add ``--show-report`` to immediately display pynose reports after the test suite completes. Only use ``--show-report`` when running tests locally because it pauses the test run.)\n\nbehave Dashboard & Reports:\n\n(The [behave_bdd/](https://github.com/seleniumbase/SeleniumBase/tree/master/examples/behave_bdd) folder can be found in the [examples/](https://github.com/seleniumbase/SeleniumBase/tree/master/examples) folder.)\n\nYou can also use ``--junit`` to get ``.xml`` reports for each behave feature. Jenkins can use these files to display better reporting for your tests.\n\nAllure Reports:\n\nSee: [https://allurereport.org/docs/pytest/](https://allurereport.org/docs/pytest/)\n\nSeleniumBase no longer includes ``allure-pytest`` as part of installed dependencies. If you want to use it, install it first:\n\nNow your tests can create Allure results files, which can be processed by Allure Reports.\n\n--------\n\nUsing a Proxy Server:\n\nIf you wish to use a proxy server for your browser tests (Chromium or Firefox), you can add ``--proxy=IP_ADDRESS:PORT`` as an argument on the command line.\n\nIf the proxy server that you wish to use requires authentication, you can do the following (Chromium only):\n\nSeleniumBase also supports SOCKS4 and SOCKS5 proxies:\n\nTo make things easier, you can add your frequently-used proxies to PROXY_LIST in [proxy_list.py](https://github.com/seleniumbase/SeleniumBase/blob/master/seleniumbase/config/proxy_list.py), and then use ``--proxy=KEY_FROM_PROXY_LIST`` to use the IP_ADDRESS:PORT of that key.\n\nChanging the User-Agent:\n\nIf you wish to change the User-Agent for your browser tests (Chromium and Firefox only), you can add ``--agent=\"USER AGENT STRING\"`` as an argument on the command-line.\n\nHandling Pop-Up Alerts:\n\nself.accept_alert() automatically waits for and accepts alert pop-ups. self.dismiss_alert() automatically waits for and dismisses alert pop-ups. On occasion, some methods like self.click(SELECTOR) might dismiss a pop-up on its own because they call JavaScript to make sure that the readyState of the page is complete before advancing. If you're trying to accept a pop-up that got dismissed this way, use this workaround: Call self.find_element(SELECTOR).click() instead, (which will let the pop-up remain on the screen), and then use self.accept_alert() to accept the pop-up (more on that here). If pop-ups are intermittent, wrap code in a try/except block.\n\nBuilding Guided Tours for Websites:\n\nLearn about SeleniumBase Interactive Walkthroughs (in the ``examples/tour_examples/`` folder). It's great for prototyping a website onboarding experience.\n\n--------\n\nProduction Environments & Integrations:",
      "word_count": 493
    },
    {
      "chunk_id": "seleniumbase::chunk_5",
      "text": "▶️ Here are some things you can do to set up a production environment for your testing. (click to expand)\n\nYou can set up a Jenkins build server for running tests at regular intervals. For a real-world Jenkins example of headless browser automation in action, check out the SeleniumBase Jenkins example on Azure or the SeleniumBase Jenkins example on Google Cloud.\n\nYou can use the Selenium Grid to scale your testing by distributing tests on several machines with parallel execution. To do this, check out the SeleniumBase selenium_grid folder, which should have everything you need, including the Selenium Grid ReadMe to help you get started.\n\nIf you're using the SeleniumBase MySQL feature to save results from tests running on a server machine, you can install MySQL Workbench to help you read & write from your DB more easily.\n\nIf you're using AWS, you can set up an Amazon S3 account for saving log files and screenshots from your tests. To activate this feature, modify settings.py with connection details in the S3 section, and add --with-s3-logging on the command-line when running your tests.\n\nHere's an example of running tests with some additional features enabled:\n\nDetailed Method Specifications and Examples:\n\n**Navigating to a web page: (and related commands)**\n\nProTip™: You can use the self.get_page_source() method with Python's find() command to parse through HTML to find something specific. (For more advanced parsing, see the BeautifulSoup example.)\n\n**Clicking:**\n\nTo click an element on the page:\n\n**ProTip™:** In most web browsers, you can right-click on a page and select ``Inspect Element`` to see the CSS selector details that you'll need to create your own scripts.\n\n**Typing Text:**\n\nself.type(selector, text)  # updates the text from the specified element with the specified value. An exception is raised if the element is missing or if the text field is not editable. Example:\n\nYou can also use self.add_text() or the WebDriver .send_keys() command, but those won't clear the text box first if there's already text inside.\n\n**Getting the text from an element on a page:**\n\n**Getting the attribute value from an element on a page:**\n\n**Asserting existence of an element on a page within some number of seconds:**\n\n(NOTE: You can also use: ``self.assert_element_present(ELEMENT)``)\n\n**Asserting visibility of an element on a page within some number of seconds:**\n\n(NOTE: The short versions of that are ``self.find_element(ELEMENT)`` and ``self.assert_element(ELEMENT)``. The ``find_element()`` version returns the element.)\n\nSince the line above returns the element, you can combine that with ``.click()`` as shown below:\n\n**ProTip™:** You can use dots to signify class names (Ex: ``div.class_name``) as a simplified version of ``div[class=\"class_name\"]`` within a CSS selector.\n\nYou can also use ``*=`` to search for any partial value in a CSS selector as shown below:\n\n**Asserting visibility of text inside an element on a page within some number of seconds:**\n\n(NOTE: ``self.find_text(TEXT, ELEMENT)`` and ``self.wait_for_text(TEXT, ELEMENT)`` also do this. For backwards compatibility, older method names were kept, but the default timeout may be different.)\n\n**Asserting Anything:**\n\n**Useful Conditional Statements: (with creative examples)**",
      "word_count": 496
    },
    {
      "chunk_id": "seleniumbase::chunk_6",
      "text": "``is_element_visible(selector):``  (visible on the page)\n\n``is_element_present(selector):``  (present in the HTML)\n\n``is_text_visible(text, selector):``  (text visible on element)\n\n▶️ Click for a longer example of is_text_visible():\n\n``is_link_text_visible(link_text):``\n\nSwitching Tabs:\n\nIf your test opens up a new tab/window, you can switch to it. (SeleniumBase automatically switches to new tabs that don't open to about:blank URLs.)\n\nHow to handle iframes:\n\niframes follow the same principle as new windows: You must first switch to the iframe if you want to perform actions in there:\n\nTo exit from multiple iframes, use ``self.switch_to_default_content()``. (If inside a single iframe, this has the same effect as ``self.switch_to_parent_frame()``.)\n\nYou can also use a context manager to act inside iframes:\n\nThis also works with nested iframes:\n\nHow to execute custom jQuery scripts:\n\njQuery is a powerful JavaScript library that allows you to perform advanced actions in a web browser.\nIf the web page you're on already has jQuery loaded, you can start executing jQuery scripts immediately.\nYou'd know this because the web page would contain something like the following in the HTML:\n\nIt's OK if you want to use jQuery on a page that doesn't have it loaded yet. To do so, run the following command first:\n\n▶️ Here are some examples of using jQuery in your scripts. (click to expand)\n\n(Most of the above commands can be done directly with built-in SeleniumBase methods.)\n\nHow to handle a restrictive CSP:\n\nSome websites have a restrictive [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) to prevent users from loading jQuery and other external libraries onto their websites. If you need to use jQuery or another JS library on those websites, add ``--disable-csp`` as a ``pytest`` command-line option to load a Chromium extension that bypasses the CSP.\n\nMore JavaScript fun:\n\n▶️ In this example, JavaScript creates a referral button on a page, which is then clicked. (click to expand)\n\n(Due to popular demand, this traffic generation example has been included in SeleniumBase with the self.generate_referral(start_page, end_page) and the self.generate_traffic(start_page, end_page, loops) methods.)\n\nHow to use deferred asserts:\n\nLet's say you want to verify multiple different elements on a web page in a single test, but you don't want the test to fail until you verified several elements at once so that you don't have to rerun the test to find more missing elements on the same page. That's where deferred asserts come in. Here's an example:\n\ndeferred_assert_element() and deferred_assert_text() will save any exceptions that would be raised.\nTo flush out all the failed deferred asserts into a single exception, make sure to call self.process_deferred_asserts() at the end of your test method. If your test hits multiple pages, you can call self.process_deferred_asserts() before navigating to a new page so that the screenshot from your log files matches the URL where the deferred asserts were made.\n\nHow to access raw WebDriver:\n\nIf you need access to any commands that come with standard WebDriver, you can call them directly like this:\n\n(In general, you'll want to use the SeleniumBase versions of methods when available.)\n\nHow to retry failing tests automatically:",
      "word_count": 499
    },
    {
      "chunk_id": "seleniumbase::chunk_7",
      "text": "You can use pytest --reruns=NUM to retry failing tests that many times. Add --reruns-delay=SECONDS to wait that many seconds between retries. Example:\n\nYou can use the @retry_on_exception() decorator to retry failing methods. (First import: from seleniumbase import decorators). To learn more about SeleniumBase decorators, click here.\n\n--------\n\n> \"Catch bugs in QA before deploying code to Production!\"\n\n--------\n\nWrap-Up\n\nIf you see something, say something!",
      "word_count": 65
    }
  ],
  "usage_description": "This library is used to automate web interactions, end-to-end testing, and web scraping with ease. With SeleniumBase, developers can handle modern web challenges and innovate faster by leveraging its stealth options and comprehensive API."
}