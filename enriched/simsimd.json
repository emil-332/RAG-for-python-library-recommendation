{
  "name": "simsimd",
  "summary": "Portable mixed-precision BLAS-like vector math library for x86 and ARM",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "ml",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "simsimd::chunk_0",
      "text": "Features\n\n__SimSIMD__ (Arabic: \"سيمسيم دي\") is a mixed-precision math library of __over 350 SIMD-optimized kernels__ extensively used in AI, Search, and DBMS workloads.\nNamed after the iconic [\"Open Sesame\"](https://en.wikipedia.org/wiki/Open_sesame) command that opened doors to treasure in _Ali Baba and the Forty Thieves_, SimSIMD can help you 10x the cost-efficiency of your computational pipelines.\nImplemented distance functions include:\n\n- Euclidean (L2) and Cosine (Angular) spatial distances for Vector Search. _[docs][docs-spatial]_\n- Dot-Products for real & complex vectors for DSP & Quantum computing. _[docs][docs-dot]_\n- Hamming (~ Manhattan) and Jaccard (~ Tanimoto) bit-level distances. _[docs][docs-binary]_\n- Set Intersections for Sparse Vectors and Text Analysis. _[docs][docs-sparse]_\n- Mahalanobis distance and Quadratic forms for Scientific Computing. _[docs][docs-curved]_\n- Kullback-Leibler and Jensen–Shannon divergences for probability distributions. _[docs][docs-probability]_\n- Fused-Multiply-Add (FMA) and Weighted Sums to replace BLAS level 1 functions. _[docs][docs-fma]_\n- For Levenshtein, Needleman–Wunsch, and Smith-Waterman, check [StringZilla][stringzilla].\n-  Haversine and Vincenty's formulae for Geospatial Analysis.\n\n[docs-spatial]: #cosine-similarity-reciprocal-square-root-and-newton-raphson-iteration\n[docs-curved]: #curved-spaces-mahalanobis-distance-and-bilinear-quadratic-forms\n[docs-sparse]: #set-intersection-galloping-and-binary-search\n[docs-dot]: #complex-dot-products-conjugate-dot-products-and-complex-numbers\n[docs-probability]: #logarithms-in-kullback-leibler--jensenshannon-divergences\n[docs-fma]: #mixed-precision-in-fused-multiply-add-and-weighted-sums\n\nMoreover, SimSIMD...\n\n- handles `float64`, `float32`, `float16`, and `bfloat16` real & complex vectors.\n- handles `int8` integral, `int4` sub-byte, and `b8` binary vectors.\n- handles sparse `uint32` and `uint16` sets, and weighted sparse vectors.\n- is a zero-dependency [header-only C 99](#using-simsimd-in-c) library.\n- has [Python](#using-simsimd-in-python), [Rust](#using-simsimd-in-rust), [JS](#using-simsimd-in-javascript), and [Swift](#using-simsimd-in-swift) bindings.\n- has Arm backends for NEON, Scalable Vector Extensions (SVE), and SVE2.\n- has x86 backends for Haswell, Skylake, Ice Lake, Genoa, and Sapphire Rapids.\n- with both compile-time and runtime CPU feature detection easily integrates anywhere!\n\nDue to the high-level of fragmentation of SIMD support in different x86 CPUs, SimSIMD generally uses the names of select Intel CPU generations for its backends.\nThey, however, also work on AMD CPUs.\nIntel Haswell is compatible with AMD Zen 1/2/3, while AMD Genoa Zen 4 covers AVX-512 instructions added to Intel Skylake and Ice Lake.\nYou can learn more about the technical implementation details in the following blog-posts:\n\nBenchmarks\n\n> For benchmarks we mostly use 1536-dimensional vectors, like the embeddings produced by the OpenAI Ada API.\n> The code was compiled with GCC 12, using glibc v2.35.\n> The benchmarks performed on Arm-based Graviton3 AWS `c7g` instances and `r7iz` Intel Sapphire Rapids.\n> Most modern Arm-based 64-bit CPUs will have similar relative speedups.\n> Variance within x86 CPUs will be larger.\n\nSimilar speedups are often observed even when compared to BLAS and LAPACK libraries underlying most numerical computing libraries, including NumPy and SciPy in Python.\nBroader benchmarking results:\n\nUsing SimSIMD in Python\n\nThe package is intended to replace the usage of `numpy.inner`, `numpy.dot`, and `scipy.spatial.distance`.\nAside from drastic performance improvements, SimSIMD significantly improves accuracy in mixed precision setups.\nNumPy and SciPy, processing `int8`, `uint8` or `float16` vectors, will use the same types for accumulators, while SimSIMD can combine `int8` enumeration, `int16` multiplication, and `int32` accumulation to avoid overflows entirely.\nThe same applies to processing `float16` and `bfloat16` values with `float32` precision.\n\nInstallation\n\nUse the following snippet to install SimSIMD and list hardware acceleration options available on your machine:",
      "word_count": 499
    },
    {
      "chunk_id": "simsimd::chunk_1",
      "text": "With precompiled binaries, SimSIMD ships `.pyi` interface files for type hinting and static analysis.\nYou can check all the available functions in [`python/annotations/__init__.pyi`](https://github.com/ashvardanian/SimSIMD/blob/main/python/annotations/__init__.pyi).\n\nOne-to-One Distance\n\nSupported functions include `cosine`, `inner`, `sqeuclidean`, `hamming`, `jaccard`, `kullbackleibler`, `jensenshannon`, and `intersect`.\nDot products are supported for both real and complex numbers:\n\nUnlike SciPy, SimSIMD allows explicitly stating the precision of the input vectors, which is especially useful for mixed-precision setups.\nThe `dtype` argument can be passed both by name and as a positional argument:\n\nBinary distance functions are computed at a bit-level.\nMeaning a vector of 10x 8-bit integers will be treated as a sequence of 80 individual bits or dimensions.\nThis differs from NumPy, that can't handle smaller-than-byte types, but you can still avoid the `bin8` argument by reinterpreting the vector as booleans:\n\nWith other frameworks, like PyTorch, one can get a richer type-system than NumPy, but the lack of good CPython interoperability makes it hard to pass data without copies.\nHere is an example of using SimSIMD with PyTorch to compute the cosine similarity between two `bfloat16` vectors:\n\nIt also allows using SimSIMD for half-precision complex numbers, which NumPy does not support.\nFor that, view data as continuous even-length `np.float16` vectors and override type-resolution with `complex32` string.\n\nWhen dealing with sparse representations and integer sets, you can apply the `intersect` function to two 1-dimensional arrays of `uint16` or `uint32` integers:\n\nOne-to-Many Distances\n\nEvery distance function can be used not only for one-to-one but also one-to-many and many-to-many distance calculations.\nFor one-to-many:\n\nMany-to-Many Distances\n\nAll distance functions in SimSIMD can be used to compute many-to-many distances.\nFor two batches of 100 vectors to compute 100 distances, one would call it like this:\n\nInput matrices must have identical shapes.\nThis functionality isn't natively present in NumPy or SciPy, and generally requires creating intermediate arrays, which is inefficient and memory-consuming.\n\nMany-to-Many All-Pairs Distances\n\nOne can use SimSIMD to compute distances between all possible pairs of rows across two matrices (akin to [`scipy.spatial.distance.cdist`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html)).\nThe resulting object will have a type `DistancesTensor`, zero-copy compatible with NumPy and other libraries.\nFor two arrays of 10 and 1,000 entries, the resulting tensor will have 10,000 cells:\n\nElement-wise Kernels\n\nSimSIMD also provides mixed-precision element-wise kernels, where the input vectors and the output have the same numeric type, but the intermediate accumulators are of a higher precision.\n\nSimilarly, the `fma` takes three arguments and computes the fused multiply-add operation.\nIn applications like Machine Learning you may also benefit from using the \"brain-float\" format not natively supported by NumPy.\nIn 3D Graphics, for example, we can use FMA to compute the [Phong shading model](https://en.wikipedia.org/wiki/Phong_shading):\n\nMultithreading and Memory Usage\n\nBy default, computations use a single CPU core.\nTo override this behavior, use the `threads` argument.\nSet it to `0` to use all available CPU cores and let the underlying C library manage the thread pool.\nHere is an example of dealing with large sets of binary vectors:",
      "word_count": 484
    },
    {
      "chunk_id": "simsimd::chunk_2",
      "text": "Alternatively, when using free-threading Python 3.13t builds, one can combine single-threaded SimSIMD operations with Python's `concurrent.futures.ThreadPoolExecutor` to parallelize the computations.\nBy default, the output distances will be stored in double-precision `float64` floating-point numbers.\nThat behavior may not be space-efficient, especially if you are computing the hamming distance between short binary vectors, that will generally fit into 8x smaller `uint8` or `uint16` types.\nTo override this behavior, use the `out_dtype` argument, or consider pre-allocating the output array and passing it to the `out` argument.\nA more complete example may look like this:\n\nUsing Python API with USearch\n\nWant to use it in Python with [USearch](https://github.com/unum-cloud/usearch)?\nYou can wrap the raw C function pointers SimSIMD backends into a `CompiledMetric` and pass it to USearch, similar to how it handles Numba's JIT-compiled code.\n\nUsing SimSIMD in Rust\n\nTo install, add the following to your `Cargo.toml`:\n\nBefore using the SimSIMD library, ensure you have imported the necessary traits and types into your Rust source file.\nThe library provides several traits for different distance/similarity kinds - `SpatialSimilarity`, `BinarySimilarity`, and `ProbabilitySimilarity`.\n\nSpatial Similarity: Cosine and Euclidean Distances\n\nSpatial similarity functions are available for `f64`, `f32`, `f16`, and `i8` types.\n\nDot-Products: Inner and Complex Inner Products\n\nComplex inner products are available for `f64`, `f32`, and `f16` types.\n\nProbability Distributions: Jensen-Shannon and Kullback-Leibler Divergences\n\nProbability similarity functions are available for `f64`, `f32`, and `f16` types.\n\nBinary Similarity: Hamming and Jaccard Distances\n\nSimilar to spatial distances, one can compute bit-level distance functions between slices of unsigned integers:\n\nBinary similarity functions are available only for `u8` types.\n\nHalf-Precision Floating-Point Numbers\n\nRust has no native support for half-precision floating-point numbers, but SimSIMD provides a `f16` type with built-in conversion methods.\nThe underlying `u16` representation is publicly accessible for direct bit manipulation.\n\nFor interoperability with the `half` crate:\n\nHalf-Precision Brain-Float Numbers\n\nThe \"brain-float-16\" is a popular machine learning format.\nIt's broadly supported in hardware and is very machine-friendly, but software support is still lagging behind.\n[Unlike NumPy](https://github.com/numpy/numpy/issues/19808), you can already use `bf16` datatype in SimSIMD.\nSimSIMD provides a `bf16` type with built-in conversion methods and direct bit access.\n\nDynamic Dispatch in Rust\n\nSimSIMD provides a [dynamic dispatch](#dynamic-dispatch) mechanism to select the most advanced micro-kernel for the current CPU.\nYou can query supported backends and use the `SimSIMD::capabilities` function to select the best one.\n\nUsing SimSIMD in JavaScript\n\nTo install, choose one of the following options depending on your environment:\n\n- `npm install --save simsimd`\n- `yarn add simsimd`\n- `pnpm add simsimd`\n- `bun install simsimd`\n\nThe package is distributed with prebuilt binaries, but if your platform is not supported, you can build the package from the source via `npm run build`.\nThis will automatically happen unless you install the package with the `--ignore-scripts` flag or use Bun.\nAfter you install it, you will be able to call the SimSIMD functions on various `TypedArray` variants:\n\nOther numeric types and precision levels are supported as well.\nFor double-precision floating-point numbers, use `Float64Array`:",
      "word_count": 489
    },
    {
      "chunk_id": "simsimd::chunk_3",
      "text": "When doing machine learning and vector search with high-dimensional vectors you may want to quantize them to 8-bit integers.\nYou may want to project values from the $[-1, 1]$ range to the $[-127, 127]$ range and then cast them to `Int8Array`:\n\nA more extreme quantization case would be to use binary vectors.\nYou can map all positive values to `1` and all negative values and zero to `0`, packing eight values into a single byte.\nAfter that, Hamming and Jaccard distances can be computed.\n\nUsing SimSIMD in Swift\n\nTo install, simply add the following dependency to your `Package.swift`:\n\nThe package provides the most common spatial metrics for `Int8`, `Float16`, `Float32`, and `Float64` vectors.\n\nUsing SimSIMD in C\n\nFor integration within a CMake-based project, add the following segment to your `CMakeLists.txt`:\n\nAfter that, you can use the SimSIMD library in your C code in several ways.\nSimplest of all, you can include the headers, and the compiler will automatically select the most recent CPU extensions that SimSIMD will use.\n\nDynamic Dispatch in C\n\nTo avoid hard-coding the backend, you can rely on `c/lib.c` to prepackage all possible backends in one binary, and select the most recent CPU features at runtime.\nThat feature of the C library is called [dynamic dispatch](#dynamic-dispatch) and is extensively used in the Python, JavaScript, and Rust bindings.\nTo test which CPU features are available on the machine at runtime, use the following APIs:\n\nTo override compilation settings and switch between runtime and compile-time dispatch, define the following macro:\n\nSpatial Distances: Cosine and Euclidean Distances\n\nDot-Products: Inner and Complex Inner Products\n\nBinary Distances: Hamming and Jaccard Distances\n\nProbability Distributions: Jensen-Shannon and Kullback-Leibler Divergences\n\nHalf-Precision Floating-Point Numbers\n\nIf you aim to utilize the `_Float16` functionality with SimSIMD, ensure your development environment is compatible with C 11.\nFor other SimSIMD functionalities, C 99 compatibility will suffice.\nTo explicitly disable half-precision support, define the following macro before imports:\n\nCompilation Settings and Debugging\n\n`SIMSIMD_DYNAMIC_DISPATCH`:\n\n> By default, SimSIMD is a header-only library.\n> But if you are running on different generations of devices, it makes sense to pre-compile the library for all supported generations at once, and dispatch at runtime.\n> This flag does just that and is used to produce the `simsimd.so` shared library, as well as the Python and other bindings.\n\nFor Arm: `SIMSIMD_TARGET_NEON`, `SIMSIMD_TARGET_SVE`, `SIMSIMD_TARGET_SVE2`, `SIMSIMD_TARGET_NEON_F16`, `SIMSIMD_TARGET_SVE_F16`, `SIMSIMD_TARGET_NEON_BF16`, `SIMSIMD_TARGET_SVE_BF16`.\nFor x86: `SIMSIMD_TARGET_HASWELL`, `SIMSIMD_TARGET_SKYLAKE`, `SIMSIMD_TARGET_ICE`, `SIMSIMD_TARGET_GENOA`, `SIMSIMD_TARGET_SAPPHIRE`, `SIMSIMD_TARGET_TURIN`, `SIMSIMD_TARGET_SIERRA`.\n\n> By default, SimSIMD automatically infers the target architecture and pre-compiles as many kernels as possible.\n> In some cases, you may want to explicitly disable some of the kernels.\n> Most often it's due to compiler support issues, like the lack of some recent intrinsics or low-precision numeric types.\n> In other cases, you may want to disable some kernels to speed up the compilation process and trim the binary size.\n\n`SIMSIMD_SQRT`, `SIMSIMD_RSQRT`, `SIMSIMD_LOG`:",
      "word_count": 474
    },
    {
      "chunk_id": "simsimd::chunk_4",
      "text": "> By default, for __non__-SIMD backends, SimSIMD may use `libc` functions like `sqrt` and `log`.\n> Those are generally very accurate, but slow, and introduce a dependency on the C standard library.\n> To avoid that you can override those definitions with your custom implementations, like: `#define SIMSIMD_RSQRT(x) (1 / sqrt(x))`.\n\nAlgorithms & Design Decisions\n\nIn general there are a few principles that SimSIMD follows:\n\n- Avoid loop unrolling.\n- Never allocate memory.\n- Never throw exceptions or set `errno`.\n- Keep all function arguments the size of the pointer.\n- Avoid returning from public interfaces, use out-arguments instead.\n- Don't over-optimize for old CPUs and single- and double-precision floating-point numbers.\n- Prioritize mixed-precision and integer operations, and new ISA extensions.\n- Prefer saturated arithmetic and avoid overflows.\n\nPossibly, in the future:\n\n- Best effort computation silencing `NaN` components in low-precision inputs.\n- Detect overflows and report the distance with a \"signaling\" `NaN`.\n\nLast, but not the least - don't build unless there is a demand for it.\nSo if you have a specific use-case, please open an issue or a pull request, and ideally, bring in more users with similar needs.\n\nCosine Similarity, Reciprocal Square Root, and Newton-Raphson Iteration\n\nThe cosine similarity is the most common and straightforward metric used in machine learning and information retrieval.\nInterestingly, there are multiple ways to shoot yourself in the foot when computing it.\nThe cosine similarity is the inverse of the cosine distance, which is the cosine of the angle between two vectors.\n\nIn NumPy terms, SimSIMD implementation is similar to:\n\nIn SciPy, however, the cosine distance is computed as `1 - ab / np.sqrt(a2 * b2)`.\nIt handles the edge case of a zero and non-zero argument pair differently, resulting in a division by zero error.\nIt's not only less efficient, but also less accurate, given how the reciprocal square roots are computed.\nThe C standard library provides the `sqrt` function, which is generally very accurate, but slow.\nThe `rsqrt` in-hardware implementations are faster, but have different accuracy characteristics.\n\n- SSE `rsqrtps` and AVX `vrsqrtps`: $1.5 \\times 2^{-12}$ maximal relative error.\n- AVX-512 `vrsqrt14pd` instruction: $2^{-14}$ maximal relative error.\n- NEON `frsqrte` instruction has no documented error bounds, but [can be][arm-rsqrt] $2^{-3}$.\n\nTo overcome the limitations of the `rsqrt` instruction, SimSIMD uses the Newton-Raphson iteration to refine the initial estimate for high-precision floating-point numbers.\nIt can be defined as:\n\nOn 1536-dimensional inputs on Intel Sapphire Rapids CPU a single such iteration can result in a 2-3 orders of magnitude relative error reduction:\n\nDatatype\n:---------\n`bfloat16`\n`float16`\n`float32`\n`float64`\n\nCurved Spaces, Mahalanobis Distance, and Bilinear Quadratic Forms\n\nThe Mahalanobis distance is a generalization of the Euclidean distance, which takes into account the covariance of the data.\nIt's very similar in its form to the bilinear form, which is a generalization of the dot product.\n\nBilinear Forms can be seen as one of the most important linear algebraic operations, surprisingly missing in BLAS and LAPACK.\nThey are versatile and appear in various domains:",
      "word_count": 500
    },
    {
      "chunk_id": "simsimd::chunk_5",
      "text": "- In Quantum Mechanics, the expectation value of an observable $A$ in a state $\\psi$ is given by $\\langle \\psi | A | \\psi \\rangle$, which is a bilinear form.\n- In Machine Learning, in Support Vector Machines (SVMs), bilinear forms define kernel functions that measure similarity between data points.\n- In Differential Geometry, the metric tensor, which defines distances and angles on a manifold, is a bilinear form on the tangent space.\n- In Economics, payoff functions in certain Game Theoretic problems can be modeled as bilinear forms of players' strategies.\n- In Physics, interactions between electric and magnetic fields can be expressed using bilinear forms.\n\nBroad applications aside, the lack of a specialized primitive for bilinear forms in BLAS and LAPACK means significant performance overhead.\nA $vector * matrix * vector$ product is a scalar, whereas its constituent parts ($vector * matrix$ and $matrix * vector$) are vectors:\n\n- They need memory to be stored in: $O(n)$ allocation.\n- The data will be written to memory and read back, wasting CPU cycles.\n\nSimSIMD doesn't produce intermediate vector results, like `a @ M @ b`, but computes the bilinear form directly.\n\nSet Intersection, Galloping, and Binary Search\n\nThe set intersection operation is generally defined as the number of elements that are common between two sets, represented as sorted arrays of integers.\nThe most common way to compute it is a linear scan:\n\nAlternatively, one can use the binary search to find the elements in the second array that are present in the first one.\nOn every step the checked region of the second array is halved, which is called the _galloping search_.\nIt's faster, but only when large arrays of very different sizes are intersected.\nThird approach is to use the SIMD instructions to compare multiple elements at once:\n\n- Using string-intersection instructions on x86, like `pcmpestrm`.\n- Using integer-intersection instructions in AVX-512, like `vp2intersectd`.\n- Using vanilla equality checks present in all SIMD instruction sets.\n\nAfter benchmarking, the last approach was chosen, as it's the most flexible and often the fastest.\n\nComplex Dot Products, Conjugate Dot Products, and Complex Numbers\n\nComplex dot products are a generalization of the dot product to complex numbers.\nThey are supported by most BLAS packages, but almost never in mixed precision.\nSimSIMD defines `dot` and `vdot` kernels as:\n\nWhere $\\bar{b_i}$ is the complex conjugate of $b_i$.\nPutting that into Python code for scalar arrays:\n\nLogarithms in Kullback-Leibler & Jensen–Shannon Divergences\n\nThe Kullback-Leibler divergence is a measure of how one probability distribution diverges from a second, expected probability distribution.\nJensen-Shannon divergence is a symmetrized and smoothed version of the Kullback-Leibler divergence, which can be used as a distance metric between probability distributions.\n\nBoth functions are defined for non-negative numbers, and the logarithm is a key part of their computation.\n\nMixed Precision in Fused-Multiply-Add and Weighted Sums\n\nThe Fused-Multiply-Add (FMA) operation is a single operation that combines element-wise multiplication and addition with different scaling factors.\nThe Weighted Sum is its simplified variant without element-wise multiplication.",
      "word_count": 500
    },
    {
      "chunk_id": "simsimd::chunk_6",
      "text": "In NumPy terms, the implementation may look like:\n\nThe tricky part is implementing those operations in mixed precision, where the scaling factors are of different precision than the input and output vectors.\nSimSIMD uses double-precision floating-point scaling factors for any input and output precision, including `i8` and `u8` integers and `f16` and `bf16` floats.\nDepending on the generation of the CPU, given native support for `f16` addition and multiplication, the `f16` temporaries are used for `i8` and `u8` multiplication, scaling, and addition.\nFor `bf16`, native support is generally limited to dot-products with subsequent partial accumulation, which is not enough for the FMA and WSum operations, so `f32` is used as a temporary.\n\nAuto-Vectorization & Loop Unrolling\n\nOn the Intel Sapphire Rapids platform, SimSIMD was benchmarked against auto-vectorized code using GCC 12.\nGCC handles single-precision `float` but might not be the best choice for `int8` and `_Float16` arrays, which have been part of the C language since 2011.\n\nKind\n:------------------------\nInner Product\nCosine Distance\nEuclidean Distance ²\nJensen-Shannon Divergence\n\nDynamic Dispatch\n\nMost popular software is precompiled and distributed with fairly conservative CPU optimizations, to ensure compatibility with older hardware.\nDatabase Management platforms, like ClickHouse, and Web Browsers, like Google Chrome,need to run on billions of devices, and they can't afford to be picky about the CPU features.\nFor such users SimSIMD provides a dynamic dispatch mechanism, which selects the most advanced micro-kernel for the current CPU at runtime.\n\nYou can compile SimSIMD on an old CPU, like Intel Haswell, and run it on a new one, like AMD Genoa, and it will automatically use the most advanced instructions available.\nReverse is also true, you can compile on a new CPU and run on an old one, and it will automatically fall back to the most basic instructions.\nMoreover, the very first time you prove for CPU capabilities with `simsimd_capabilities()`, it initializes the dynamic dispatch mechanism, and all subsequent calls will be faster and won't face race conditions in multi-threaded environments.\n\nTarget Specific Backends\n\nSimSIMD exposes all kernels for all backends, and you can select the most advanced one for the current CPU without relying on built-in dispatch mechanisms.\nThat's handy for testing and benchmarking, but also in case you want to dispatch a very specific kernel for a very specific CPU, bypassing SimSIMD assignment logic.\nAll of the function names follow the same pattern: `simsimd_{function}_{type}_{backend}`.\n\n- The backend can be `serial`, `haswell`, `skylake`, `ice`, `genoa`, `sapphire`, `turin`, `neon`, or `sve`.\n- The type can be `f64`, `f32`, `f16`, `bf16`, `f64c`, `f32c`, `f16c`, `bf16c`, `i8`, or `b8`.\n- The function can be `dot`, `vdot`, `cos`, `l2sq`, `hamming`, `jaccard`, `kl`, `js`, or `intersect`.\n\nTo avoid hard-coding the backend, you can use the `simsimd_kernel_punned_t` to pun the function pointer and the `simsimd_capabilities` function to get the available backends at runtime.\nTo match all the function names, consider a RegEx:\n\nOn Linux, you can use the following command to list all unique functions:\n\nLicense",
      "word_count": 489
    },
    {
      "chunk_id": "simsimd::chunk_7",
      "text": "Feel free to use the project under Apache 2.0 or the Three-clause BSD license at your preference.",
      "word_count": 17
    }
  ],
  "usage_description": "This library is used to accelerate vector math operations in AI, Search, and DBMS workloads with up to 10x cost-efficiency improvement through its extensive set of SIMD-optimized kernels. Developers can leverage SimSIMD to implement distance functions such as Euclidean, Cosine, Hamming, and Jaccard for various applications like Vector Search, DSP, Quantum computing, and Text Analysis."
}