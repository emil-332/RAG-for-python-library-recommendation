{
  "name": "lingua-language-detector",
  "summary": "An accurate natural language detection library, suitable for short text and mixed-language text",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "ml",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "lingua-language-detector::chunk_0",
      "text": "1. What does this library do?\n\nIts task is simple: It tells you which language some text is written in.\nThis is very useful as a preprocessing step for linguistic data\nin natural language processing applications such as text classification and\nspell checking. Other use cases, for instance, might include routing e-mails\nto the right geographically located customer service department, based on the\ne-mails' languages.\n\n2. Why does this library exist?\n\nLanguage detection is often done as part of large machine learning frameworks\nor natural language processing applications. In cases where you don't need\nthe full-fledged functionality of those systems or don't want to learn the\nropes of those, a small flexible library comes in handy.\n\nPython is widely used in natural language processing, so there are a couple\nof comprehensive open source libraries for this task, such as Google's\n[*CLD 2*](https://github.com/CLD2Owners/cld2) and\n[*CLD 3*](https://github.com/google/cld3),\n[*Langid*](https://github.com/saffsd/langid.py),\n[*Simplemma*](https://github.com/adbar/simplemma) and\n[*Langdetect*](https://github.com/Mimino666/langdetect).\nUnfortunately, except for the last one they have two major drawbacks:\n\n1. Detection only works with quite lengthy text fragments. For very short\n   text snippets such as Twitter messages, they do not provide adequate results.\n2. The more languages take part in the decision process, the less accurate are\n   the detection results.\n\n*Lingua* aims at eliminating these problems. She nearly does not need any\nconfiguration and yields pretty accurate results on both long and short text,\neven on single words and phrases. She draws on both rule-based and statistical\nNaive Bayes methods but does not use neural networks or any dictionaries of words. \nShe does not need a connection to any external API or service either. \nOnce the library has been downloaded, it can be used completely offline.\n\n3. A short history of this library\n\nThis library started as a pure Python implementation. Python's quick prototyping\ncapabilities made an important contribution to its improvements. Unfortunately,\nthere was always a tradeoff between performance and memory consumption. At first,\n*Lingua's* language models were stored in dictionaries during runtime. This led\nto quick performance at the cost of large memory consumption (more than 3 GB).\nBecause of that, the language models were then stored in NumPy arrays instead of\ndictionaries. Memory consumption reduced to approximately 800 MB but CPU\nperformance dropped significantly. Both approaches were not satisfying.\n\nStarting from version 2.0.0, the pure Python implementation was replaced with\ncompiled Python bindings to the native\n[Rust implementation](https://github.com/pemistahl/lingua-rs) of *Lingua*.\nThis decision has led to both quick performance and a small memory\nfootprint of less than 1 GB. The pure Python implementation is still available\nin a [separate branch](https://github.com/pemistahl/lingua-py/tree/pure-python-impl)\nin this repository and will be kept up-to-date in subsequent 1.* releases.\nThere are environments that do not support native Python extensions such as\n[Juno](https://juno.sh/), so a pure Python implementation is still useful.\nBoth 1.* and 2.* versions will remain available on the Python package index (PyPI).\n\n4. Which languages are supported?",
      "word_count": 475
    },
    {
      "chunk_id": "lingua-language-detector::chunk_1",
      "text": "Compared to other language detection libraries, *Lingua's* focus is on\n*quality over quantity*, that is, getting detection right for a small set of\nlanguages first before adding new ones. Currently, the following 75 languages\nare supported:\n\n- A\n- B\n- C\n- D\n- E\n- F\n- G\n- H\n- I\n- J\n- K\n- L\n- M\n- N\n- P\n- R\n- S\n- T\n- U\n- V\n- W\n- X\n- Y\n- Z\n\n5. How accurate is it?\n\n*Lingua* is able to report accuracy statistics for some bundled test data\navailable for each supported language. The test data for each language is split\ninto three parts:\n\n1. a list of single words with a minimum length of 5 characters\n2. a list of word pairs with a minimum length of 10 characters\n3. a list of complete grammatical sentences of various lengths\n\nBoth the language models and the test data have been created from separate\ndocuments of the [Wortschatz corpora](https://wortschatz.uni-leipzig.de)\noffered by Leipzig University, Germany. Data crawled from various news websites\nhave been used for training, each corpus comprising one million sentences.\nFor testing, corpora made of arbitrarily chosen websites have been used, each\ncomprising ten thousand sentences. From each test corpus, a random unsorted\nsubset of 1000 single words, 1000 word pairs and 1000 sentences has been\nextracted, respectively.\n\nGiven the generated test data, I have compared the detection results of\n*Lingua*, *Langdetect*, *Langid*, *Simplemma*, *CLD 2* and *CLD 3*\nrunning over the data of *Lingua's* supported 75 languages. Languages that are\nnot supported by the other detectors are simply ignored for them during the\ndetection process.\n\nEach of the following sections contains three plots. The bar plot shows the detailed accuracy\nresults for each supported language. The box plots illustrate the distributions of the\naccuracy values for each classifier. The boxes themselves represent the areas which the\nmiddle 50 % of data lie within. Within the colored boxes, the horizontal lines mark the\nmedian of the distributions.\n\n5.1 Single word detection\n\n5.2 Word pair detection\n\n5.3 Sentence detection\n\n5.4 Average detection\n\n5.5 Mean, median and standard deviation\n\nThe tables found [here](https://github.com/pemistahl/lingua-py/tree/main/tables)\nshow detailed statistics for each language and classifier including mean, median and standard deviation.\n\n6. How fast is it?\n\nThe accuracy reporter script measures the time each language detector needs\nto classify 3000 input texts for each of the supported 75 languages. The results\nbelow have been produced on an iMac 3.6 Ghz 8-Core Intel Core i9 with 40 GB RAM.\n\nLingua in [multi-threaded mode](https://github.com/pemistahl/lingua-py#117-single-threaded-versus-multi-threaded-language-detection)\nis one of the fastest algorithms in this comparison. CLD 2 and 3\nare similarly fast as they have been implemented in C or C++. Pure Python libraries\nsuch as Simplemma, Langid or Langdetect a significantly slower.\n\nDetector\n----------------------------------------------\nLingua (low accuracy mode, multi-threaded)\nLingua (high accuracy mode, multi-threaded)\nCLD 2\nCLD 3\nLingua (low accuracy mode, single-threaded)\nLingua (high accuracy mode, single-threaded)\nSimplemma\nLangid\nLangdetect",
      "word_count": 495
    },
    {
      "chunk_id": "lingua-language-detector::chunk_2",
      "text": "7. Why is it better than other libraries?\n\nEvery language detector uses a probabilistic\n[n-gram](https://en.wikipedia.org/wiki/N-gram) model trained on the character\ndistribution in some training corpus. Most libraries only use n-grams of size 3\n(trigrams) which is satisfactory for detecting the language of longer text\nfragments consisting of multiple sentences. For short phrases or single words,\nhowever, trigrams are not enough. The shorter the input text is, the less\nn-grams are available. The probabilities estimated from such few n-grams are not\nreliable. This is why *Lingua* makes use of n-grams of sizes 1 up to 5 which\nresults in much more accurate prediction of the correct language.\n\nA second important difference is that *Lingua* does not only use such a\nstatistical model, but also a rule-based engine. This engine first determines\nthe alphabet of the input text and searches for characters which are unique\nin one or more languages. If exactly one language can be reliably chosen this\nway, the statistical model is not necessary anymore. In any case, the\nrule-based engine filters out languages that do not satisfy the conditions of\nthe input text. Only then, in a second step, the probabilistic n-gram model is\ntaken into consideration. This makes sense because loading less language models\nmeans less memory consumption and better runtime performance.\n\nIn general, it is always a good idea to restrict the set of languages to be\nconsidered in the classification process using the respective api methods.\nIf you know beforehand that certain languages are never to occur in an input\ntext, do not let those take part in the classification process. The filtering\nmechanism of the rule-based engine is quite good, however, filtering based on\nyour own knowledge of the input text is always preferable.\n\n8. Test report generation\n\nIf you want to reproduce the accuracy results above, you can generate the test\nreports yourself for all classifiers and languages by installing\n[Poetry](https://python-poetry.org) and executing:\n\nAccuracy reports for only a subset of classifiers and / or languages can be created by\npassing command line arguments:\n\nFor each detector and language, a test report file is then written into\n[`/accuracy-reports`](https://github.com/pemistahl/lingua-py/tree/main/accuracy-reports).\nAs an example, here is the current output of the *Lingua* German report:\n\n9. How to add it to your project?\n\n*Lingua* is available in the [Python Package Index](https://pypi.org/project/lingua-language-detector)\nand can be installed with:\n\n10. How to build?\n\n*Lingua* requires Python >= 3.10.\nFirst create a virtualenv and install the Python wheel for your platform with `pip`.\n\nIn the scripts directory, there are Python scripts for writing accuracy reports,\ndrawing plots and writing accuracy values in an HTML table. The dependencies\nfor these scripts are managed by [Poetry](https://python-poetry.org) which\nyou need to install if you have not done so yet. In order to install the script\ndependencies in your virtualenv, run\n\nThe project makes uses of type annotations which allow for static type checking with\n[Mypy](http://mypy-lang.org). Run the following commands for checking the types:\n\nThe Python source code is formatted with [Black](https://github.com/psf/black):\n\n11. How to use?",
      "word_count": 499
    },
    {
      "chunk_id": "lingua-language-detector::chunk_3",
      "text": "11.1 Basic usage\n\nThe entire library is thread-safe, i.e. you can use a single `LanguageDetector` instance and\nits methods in multiple threads. Multiple instances of `LanguageDetector` share thread-safe\naccess to the language models, so every language model is loaded into memory just once, no\nmatter how many instances of `LanguageDetector` have been created.\n\n11.2 Minimum relative distance\n\nBy default, *Lingua* returns the most likely language for a given input text.\nHowever, there are certain words that are spelled the same in more than one\nlanguage. The word *prologue*, for instance, is both a valid English and French\nword. *Lingua* would output either English or French which might be wrong in\nthe given context. For cases like that, it is possible to specify a minimum\nrelative distance that the logarithmized and summed up probabilities for\neach possible language have to satisfy. It can be stated in the following way:\n\nBe aware that the distance between the language probabilities is dependent on\nthe length of the input text. The longer the input text, the larger the\ndistance between the languages. So if you want to classify very short text\nphrases, do not set the minimum relative distance too high. Otherwise, `None`\nwill be returned most of the time as in the example above. This is the return\nvalue for cases where language detection is not reliably possible.\n\n11.3 Confidence values\n\nKnowing about the most likely language is nice but how reliable is the computed\nlikelihood? And how less likely are the other examined languages in comparison\nto the most likely one? These questions can be answered as well:\n\nIn the example above, a list is returned containing those languages which the\ncalling instance of LanguageDetector has been built from, sorted by\ntheir confidence value in descending order. Each value is a probability between\n0.0 and 1.0. The probabilities of all languages will sum to 1.0.\nIf the language is unambiguously identified by the rule engine, the value 1.0\nwill always be returned for this language. The other languages will receive a\nvalue of 0.0.\n\nThere is also a method for returning the confidence value for one specific\nlanguage only:\n\nThe value that this method computes is a number between 0.0 and 1.0. If the\nlanguage is unambiguously identified by the rule engine, the value 1.0 will\nalways be returned. If the given language is not supported by this detector\ninstance, the value 0.0 will always be returned.\n\n11.4 Eager loading versus lazy loading\n\nBy default, *Lingua* uses lazy-loading to load only those language models on\ndemand which are considered relevant by the rule-based filter engine. For web\nservices, for instance, it is rather beneficial to preload all language models\ninto memory to avoid unexpected latency while waiting for the service response.\nIf you want to enable the eager-loading mode, you can do it like this:\n\nMultiple instances of `LanguageDetector` share the same language models in\nmemory which are accessed asynchronously by the instances.\n\n11.5 Low accuracy mode versus high accuracy mode",
      "word_count": 499
    },
    {
      "chunk_id": "lingua-language-detector::chunk_4",
      "text": "*Lingua's* high detection accuracy comes at the cost of being noticeably slower\nthan other language detectors. The large language models also consume significant\namounts of memory. These requirements might not be feasible for systems running low\non resources. If you want to classify mostly long texts or need to save resources,\nyou can enable a *low accuracy mode* that loads only a small subset of the language\nmodels into memory:\n\nThe downside of this approach is that detection accuracy for short texts consisting\nof less than 120 characters will drop significantly. However, detection accuracy for\ntexts which are longer than 120 characters will remain mostly unaffected.\n\nIn high accuracy mode (the default), the language detector consumes approximately\n1 GB of memory if all language models are loaded. In low accuracy mode, memory\nconsumption is reduced to approximately 100 MB.\n\nAn alternative for a smaller memory footprint and faster performance is to reduce the set\nof languages when building the language detector. In most cases, it is not advisable to\nbuild the detector from all supported languages. When you have knowledge about\nthe texts you want to classify you can almost always rule out certain languages as impossible\nor unlikely to occur.\n\n11.6 Single-language mode\n\nIf you build a `LanguageDetector` from one language only it will operate in single-language mode.\nThis means the detector will try to find out whether a given text has been written in the given language or not.\nIf not, then `None` will be returned, otherwise the given language. In single-language mode, the detector decides based on a set of unique and most common n-grams which\nhave been collected beforehand for every supported language.\n\n11.7 Detection of multiple languages in mixed-language texts\n\nIn contrast to most other language detectors, *Lingua* is able to detect multiple languages\nin mixed-language texts. This feature can yield quite reasonable results but it is still\nin an experimental state and therefore the detection result is highly dependent on the input\ntext. It works best in high-accuracy mode with multiple long words for each language.\nThe shorter the phrases and their words are, the less accurate are the results. Reducing the\nset of languages when building the language detector can also improve accuracy for this task\nif the languages occurring in the text are equal to the languages supported by the respective\nlanguage detector instance.\n\nIn the example above, a list of\n[`DetectionResult`](https://github.com/pemistahl/lingua-py/blob/pure-python-impl/lingua/detector.py#L148)\nis returned. Each entry in the list describes a contiguous single-language text section,\nproviding start and end indices of the respective substring.\n\n11.8 Single-threaded versus multi-threaded language detection\n\nThe `LanguageDetector` methods explained above all operate in a single thread.\nIf you want to classify a very large set of texts, you will probably want to\nuse all available CPU cores efficiently in multiple threads for maximum performance.\n\nEvery single-threaded method has a multi-threaded equivalent that accepts a list of texts\nand returns a list of results.\n\nSingle-threaded\n--------------------------------------\n`detect_language_of`\n`detect_multiple_languages_of`\n`compute_language_confidence_values`\n`compute_language_confidence`\n\n11.9 Methods to build the LanguageDetector",
      "word_count": 498
    },
    {
      "chunk_id": "lingua-language-detector::chunk_5",
      "text": "There might be classification tasks where you know beforehand that your\nlanguage data is definitely not written in Latin, for instance. The detection\naccuracy can become better in such cases if you exclude certain languages from\nthe decision process or just explicitly include relevant languages:\n\n11.10 Differences to native Python enums\n\nAs version >= 2.0 has been implemented in Rust with Python bindings implemented\nwith [PyO3](https://pyo3.rs), there are some limitations with regard to enums.\n[PyO3 does not yet support meta classes](https://github.com/PyO3/pyo3/issues/906), \nthat's why Lingua's enums do not exactly behave like native Python enums.\n\nIf you want to iterate through all members of the `Language` enum, for instance, \nyou can do it like this:\n\nPyO3 enums are not subscriptable. If you want to get an enum member dynamically,\nyou can do it like this:\n\n12. What's next for version 2.2.0?\n\nTake a look at the [planned issues](https://github.com/pemistahl/lingua-py/milestone/10).",
      "word_count": 146
    }
  ],
  "usage_description": "Here is a 2-sentence summary of what a developer can achieve with this library:\n\nThis library is used to accurately detect the language of short texts and mixed-language texts, enabling efficient preprocessing for various natural language processing applications. By utilizing this library, developers can automate tasks such as text classification, spell checking, and routing emails to corresponding customer service departments based on language."
}