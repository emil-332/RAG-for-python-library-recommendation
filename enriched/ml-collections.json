{
  "name": "ml-collections",
  "summary": "ML Collections is a library of Python collections designed for ML usecases.",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "ml"
  ],
  "chunks": [
    {
      "chunk_id": "ml-collections::chunk_0",
      "text": "ML Collections\n\nML Collections is a library of Python Collections designed for ML use cases.\n\n(https://github.com/google/ml_collections/actions/workflows/pytest_and_autopublish.yml)\n\nConfigDict\n\nThe two classes called `ConfigDict` and `FrozenConfigDict` are \"dict-like\" data\nstructures with dot access to nested elements. Together, they are supposed to be\nused as a main way of expressing configurations of experiments and models.\n\nThis document describes example usage of `ConfigDict`, `FrozenConfigDict`,\n`FieldReference`.\n\nFeatures\n\n*   Dot-based access to fields.\n*   Locking mechanism to prevent spelling mistakes.\n*   Lazy computation.\n*   FrozenConfigDict() class which is immutable and hashable.\n*   Type safety.\n*   \"Did you mean\" functionality.\n*   Human readable printing (with valid references and cycles), using valid YAML\n*   Fields can be passed as keyword arguments using the `**` operator.\n*   There is one exception to the strong type-safety of the ConfigDict: `int`\n\nBasic Usage\n\nFrozenConfigDict\n\nA `FrozenConfigDict`is an immutable, hashable type of `ConfigDict`:\n\nFieldReferences and placeholders\n\nA `FieldReference` is useful for having multiple fields use the same value. It\ncan also be used for [lazy computation](#lazy-computation).\n\nYou can use `placeholder()` as a shortcut to create a `FieldReference` (field)\nwith a `None` default value. This is useful if a program uses optional\nconfiguration fields.\n\nNote that the indirection provided by `FieldReference`s will be lost if accessed\nthrough a `ConfigDict`.\n\nLazy computation\n\nUsing a `FieldReference` in a standard operation (addition, subtraction,\nmultiplication, etc...) will return another `FieldReference` that points to the\noriginal's value. You can use `FieldReference.get()` to execute the operations\nand get the reference's computed value, and `FieldReference.set()` to change the\noriginal reference's value.\n\nIf a `FieldReference` has `None` as its original value, or any operation has an\nargument of `None`, then the lazy computation will evaluate to `None`.\n\nWe can also use fields in a `ConfigDict` in lazy computation. In this case a\nfield will only be lazily evaluated if `ConfigDict.get_ref()` is used to get it.\n\nChanging lazily computed values\n\nLazily computed values in a ConfigDict can be overridden in the same way as\nregular values. The reference to the `FieldReference` used for the lazy\ncomputation will be lost and all computations downstream in the reference graph\nwill use the new value.\n\nCycles\n\nYou cannot create cycles using references. Fortunately\n[the only way](#changing-lazily-computed-values) to create a cycle is by\nassigning a computed field to one that *is not* the result of computation. This\nis forbidden:\n\nOne-way references\n\nOne gotcha with `get_ref` is that it creates a bi-directional dependency when no operations are performed on the value.\n\nThis can be avoided by using `get_oneway_ref` instead of `get_ref`.\n\nAdvanced usage\n\nHere are some more advanced examples showing lazy computation with different\noperators and data types.\n\nEquality checking\n\nYou can use `==` and `.eq_as_configdict()` to check equality among `ConfigDict`\nand `FrozenConfigDict` objects.\n\nEquality checking with lazy computation\n\nEquality checks see if the computed values are the same. Equality is satisfied\nif two sets of computations are different as long as they result in the same\nvalue.\n\nLocking and copying\n\nHere is an example with `lock()` and `deepcopy()`:\n\nOutput:\n\nDictionary attributes and initialization\n\nMore Examples",
      "word_count": 499
    },
    {
      "chunk_id": "ml-collections::chunk_1",
      "text": "For more examples, take a look at\n[`ml_collections/config_dict/examples/`](https://github.com/google/ml_collections/tree/master/ml_collections/config_dict/examples)\n\nFor examples and gotchas specifically about initializing a ConfigDict, see\n[`ml_collections/config_dict/examples/config_dict_initialization.py`](https://github.com/google/ml_collections/blob/master/ml_collections/config_dict/examples/config_dict_initialization.py).\n\nConfig Flags\n\nThis library adds flag definitions to `absl.flags` to handle config files. It\ndoes not wrap `absl.flags` so if using any standard flag definitions alongside\nconfig file flags, users must also import `absl.flags`.\n\nCurrently, this module adds two new flag types, namely `DEFINE_config_file`\nwhich accepts a path to a Python file that generates a configuration, and\n`DEFINE_config_dict` which accepts a configuration directly. Configurations are\ndict-like structures (see [ConfigDict](#configdict)) whose nested elements\ncan be overridden using special command-line flags. See the examples below\nfor more details.\n\nUsage\n\nUse `ml_collections.config_flags` alongside `absl.flags`. For\nexample:\n\n`script.py`:\n\n`config.py`:\n\nWarning: If you are using a pickle-based distributed programming framework such\nas [Launchpad](https://github.com/deepmind/launchpad#readme), be aware of\nlimitations on the structure of this script that are [described below]\n(#config_files_and_pickling).\n\nNow, after running:\n\nwe get:\n\nUsage of `DEFINE_config_dict` is similar to `DEFINE_config_file`, the main\ndifference is the configuration is defined in `script.py` instead of in a\nseparate file.\n\n`script.py`:\n\n`config_file` flags are compatible with the command-line flag syntax. All the\nfollowing options are supported for non-boolean values in configurations:\n\n*   `-(-)config.field=value`\n*   `-(-)config.field value`\n\nOptions for boolean values are slightly different:\n\n*   `-(-)config.boolean_field`: set boolean value to True.\n*   `-(-)noconfig.boolean_field`: set boolean value to False.\n*   `-(-)config.boolean_field=value`: `value` is `true`, `false`, `True` or\n\nNote that `-(-)config.boolean_field value` is not supported.\n\nParameterising the get_config() function\n\nIt's sometimes useful to be able to pass parameters into `get_config`, and\nchange what is returned based on this configuration. One example is if you are\ngrid searching over parameters which have a different hierarchical structure -\nthe flag needs to be present in the resulting ConfigDict. It would be possible\nto include the union of all possible leaf values in your ConfigDict,\nbut this produces a confusing config result as you have to remember which\nparameters will actually have an effect and which won't.\n\nA better system is to pass some configuration, indicating which structure of\nConfigDict should be returned. An example is the following config file:\n\nThe value of `config_string` will be anything that is to the right of the first\ncolon in the config file path, if one exists. If no colon exists, no value is\npassed to `get_config` (producing a TypeError if `get_config` expects a value).\n\nThe above example can be run like:\n\nor like:\n\nAdditional features\n\n*   Loads any valid python script which defines `get_config()` function\n*   Automatic locking of the loaded object, if the loaded object defines a\n*   Supports command-line overriding of arbitrarily nested values in dict-like\n*   Overriding is type safe.\n*   Overriding of a `tuple` can be done by passing in the `tuple` value as a\n*   The overriding `tuple` object can be of a different length and have\n\nConfig Files and Pickling {#config_files_and_pickling}\n\nThis is likely to be troublesome:\n\nThis is not:\n\nExplanation\n\nA config file is a Python module but it is not imported through Python's usual\nmodule-importing mechanism.",
      "word_count": 496
    },
    {
      "chunk_id": "ml-collections::chunk_2",
      "text": "Meanwhile, serialization libraries such as [`cloudpickle`](\npickling every type to which it refers, on the assumption that types defined\nat module scope can later be reconstructed simply by re-importing the modules\nin which they are defined.\n\nThat assumption does not hold for a type that is defined at module scope in a\nconfig file, because the config file can't be imported the usual way. The\nsymptom of this will be an `ImportError` when unpickling an object.\n\nThe treatment is to move types from module scope into `get_config()` so that\nthey will be serialized along with the values that have those types.\n\nAuthors\n*   Sergio GÃ³mez Colmenarejo - sergomez@google.com\n*   Wojciech Marian Czarnecki - lejlot@google.com\n*   Nicholas Watters\n*   Mohit Reddy - mohitreddy@google.com",
      "word_count": 122
    }
  ],
  "usage_description": "Here is a 2-sentence summary of what a developer can achieve with the ml-collections library:\n\nThis library is used to create and manage configuration objects for machine learning experiments and models, providing features such as dot-based access, locking mechanisms, and type safety. With ml-collections, developers can define and work with complex configurations in a way that is both human-readable and resistant to spelling mistakes or other errors."
}