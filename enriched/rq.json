{
  "name": "rq",
  "summary": "RQ is a simple, lightweight, library for creating background jobs, and processing them.",
  "language": "python",
  "tags": [
    "math"
  ],
  "chunks": [
    {
      "chunk_id": "rq::chunk_0",
      "text": "Support RQ\n\nIf you find RQ useful, please consider supporting this project via [Tidelift](https://tidelift.com/subscription/pkg/pypi-rq?utm_source=pypi-rq&utm_medium=referral&utm_campaign=readme).\n\nGetting started\n\nFirst, run a Redis server, of course:\n\nTo put jobs on queues, you don't have to do anything special, just define\nyour typically lengthy or blocking function:\n\nThen, create an RQ queue:\n\nAnd enqueue the function call:\n\nJob Prioritization\n\nBy default, jobs are added to the end of a single queue. RQ offers two ways to give certain jobs higher priority:\n\n1. Enqueue at the front\n\nYou can enqueue a job at the front of its queue so it’s picked up before other jobs:\n\n2. Use multiple queues\nYou can create multiple queues and enqueue jobs into different queues based on their priority:\n\nThen start workers with a prioritized queue list:\n\nThis command starts a worker that listens to both `high` and `low` queues. The worker will process\njobs from the `high` queue first, followed by the `low` queue. You can also run different workers\nfor different queues, allowing you to scale your workers based on the number of jobs in each queue.\n\nScheduling Jobs\n\nScheduling jobs is also easy:\n\nRepeating Jobs\n\nTo execute a `Job` multiple times, use the `Repeat` class:\n\nRetrying Failed Jobs\n\nRetrying failed jobs is also supported:\n\nFor a more complete example, refer to the [docs][d].  But this is the essence.\n\nInterval and Cron Job Scheduling\n\nRQ >= 2.5 provides built-in job scheduling functionality that supports both simple interval-based scheduling and flexible cron syntax.\n\nFirst, create a configuration file (e.g., `cron_config.py`) that defines the jobs you want to run periodically.\n\nAnd then start the `rq cron` command to enqueue these jobs at specified intervals:\n\nYou can also use standard cron syntax for more flexible scheduling:\n\npython\n\nMore details on functionality can be found in the [docs](https://python-rq.org/docs/cron/).\n\nThe Worker\n\nTo start executing enqueued function calls in the background, start a worker\nfrom your project's directory:\n\nTo run multiple workers in production, use process managers like `systemd`. RQ also ships with a `worker-pool` that lets you run multiple worker processes with a single command.\n\nMore options are documented on [python-rq.org](https://python-rq.org/docs/workers/).\n\nInstallation\n\nSimply use the following command to install the latest released version:\n\nNotes on Performance\n\n**TL;DR — run `Worker` or `SpawnWorker` in production.**\n\nIn a simple hello world [microbenchmark](docs/benchmark.md), `SimpleWorker` processed 1,000 jobs in just 1.02 seconds vs. 6.64 seconds with the default `Worker`), more than 6x faster.\n\n`SimpleWorker` is faster because it skips `fork()` or `spawn()` and runs jobs in process. `Worker` and `SpawnWorker` run each job in a separate process, acting as a sandbox that isolates crashes, memory leaks and enforce hard time-outs.\n\nAlthough `SimpleWorker` is faster in benchmarks, this overhead is negligible in most real world applications like sending emails, generating reports, processing images, etc. In production systems, the time spent performing jobs usually dwarfs any queueing/worker overhead.\n\nUse `SimpleWorker` in production only if:\n* Your jobs are extremely short-lived (single digit milliseconds).\n* The `fork()` or `spawn()` latency is a proven bottleneck at your traffic levels.\n* Your job code is 100% trusted and known to be free of resource leaks and the possibility of crashing/segfaults.\n\nDocs\n\nTo build and run the docs, install [jekyll](https://jekyllrb.com/docs/) and run:\n\nRelated Projects\n\nIf you use RQ, Check out these below repos which might be useful in your rq based project.\n\nProject history\n\nThis project has been inspired by the good parts of [Celery][1], [Resque][2]\nand [this snippet][3], and has been created as a lightweight alternative to the\nheaviness of Celery or other AMQP-based queueing implementations.\n\nRQ is maintained by [Stamps](https://stamps.id), an Indonesian based company that provides enterprise grade CRM and order management systems.",
      "word_count": 602
    }
  ]
}