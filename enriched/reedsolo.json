{
  "name": "reedsolo",
  "summary": "Pure-Python Reed Solomon encoder/decoder",
  "language": "python",
  "tags": [
    "math",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "reedsolo::chunk_0",
      "text": "Reed Solomon\n============\n\nPyPI-Status\n\nBuild-Status\n\nConda-Forge-Status\n\nA pythonic `universal errors-and-erasures Reed-Solomon Codec `_ to protect your data from errors and bitrot. It includes a pure python implementation and an optional speed-optimized Cython/C extension.\n\nThis is a burst-type implementation, so that it supports any Galois field higher than 2^3, but not binary streams. Burst errors are non-random errors that more often happen on data storage mediums such as hard drives, hence this library is better suited for data storage protection, and less for streams noise correction, although it also works for this purpose but with a bit of overhead (since it works with bytes only, instead of bits).\n\nBased on the wonderful tutorial at `Wikiversity `_, written by \"Bobmath\" and \"LRQ3000\". If you are just starting with Reed-Solomon error correction codes, the Wikiversity article is a good beginner's introduction.\n\n------------------------------------\n\n.. contents:: Table of contents\n   :backlinks: top\n   :local:\n\nInstallation\n------------\n\nFor the latest stable release, install with:\n\n.. code:: sh\n\nFor the latest development release (do not use in production!), use:\n\n.. code:: sh\n\nIf you have some issues installing through pip, maybe this command may help:\n\n.. code:: sh\n\nBy default, only a pure-python implementation is installed. If you have Cython and a C++ compiler, a faster cythonized binary can be optionally built with:\n.. code:: sh\nor locally with:\n\n.. code:: sh\n\nThe setup.py will then try to build the Cython optimized module ``creedsolo.pyx`` if Cython is installed, which can then be imported as `import creedsolo` instead of `import reedsolo`, with the same features between both modules.\n\nAs an alternative, use `conda `_ to install a compiled version for various platforms:\n\n.. code:: sh\n\nUsage\n-----\n\nBasic usage with high-level RSCodec class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n**Important upgrade notice for pre-1.0 users:** Note that ``RSCodec.decode()`` returns 3 variables:\n\nHere is how to use these outputs:\n\n.. code:: python\n\nSince we failed to decode with 6 errors with a codec set with 10 error correction code (ecc) symbols, let's try to use a bigger codec, with 12 ecc symbols.\n\n.. code:: python\n\nThis shows that we can decode twice as many erasures (where we provide the location of errors ourselves) than errors (with unknown locations). This is the cost of error correction compared to erasure correction.\n\nTo get the maximum number of errors *or* erasures that can be independently corrected (ie, not simultaneously):\n\n.. code:: python\n\nTo get the maximum number of errors *and* erasures that can be simultaneously corrected, you need to specify the number of errors or erasures you expect:\n\n.. code:: python",
      "word_count": 425
    },
    {
      "chunk_id": "reedsolo::chunk_1",
      "text": "Note that if a chunk has more errors and erasures than the Singleton Bound as calculated by the ``maxerrata()`` method, the codec will try to raise a ``ReedSolomonError`` exception,\nbut may very well not detect any error either (this is a theoretical limitation of error correction codes). In other words, error correction codes are unreliable to detect if a chunk of a message\nis corrupted beyond the Singleton Bound. If you want more reliability in errata detection, use a checksum or hash such as SHA or MD5 on your message, these are much more reliable and have no bounds\non the number of errata (the only potential issue is with collision but the probability is very very low).\n\nNote: to catch a ``ReedSolomonError`` exception, do not forget to import it first with: ``from reedsolo import ReedSolomonError``\n\nTo check if a message is tampered given its error correction symbols, without decoding, use the ``check()`` method:\n\n.. code:: python\n\nBy default, most Reed-Solomon codecs are limited to characters that can be encoded in 256 bits and with a length of maximum 256 characters. But this codec is universal, you can reduce or increase the length and maximum character value by increasing the Galois Field:\n\n.. code:: python\n\nNote that the ``RSCodec`` class supports transparent chunking, so you don't need to increase the Galois Field to support longer messages, but characters will still be limited to 256 bits (or\nwhatever field you set with ``c_exp``).\n\nLow-level usage via direct access to math functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want full control, you can skip the API and directly use the library as-is. Here's how:\n\nFirst you need to init the precomputed tables:\n\n.. code:: python\n\nPro tip: if you get the error: ValueError: byte must be in range(0, 256), please check that your prime polynomial is correct for your field.\nPro tip2: by default, you can only encode messages of max length and max symbol value = 256. If you want to encode bigger messages,\nplease use the following (where c_exp is the exponent of your Galois Field, eg, 12 = max length 2^12 = 4096):\n\n.. code:: python\n\nLet's define our RS message and ecc size:\n\n.. code:: python\n\nTo optimize, you can precompute the generator polynomial:\n\n.. code:: python\n\nThen to encode:\n\n.. code:: python\n\nLet's tamper our message:\n\n.. code:: python\n\nTo decode:\n\n.. code:: python\n\nNote that both the message and the ecc are corrected (if possible of course).\nPro tip: if you know a few erasures positions, you can specify them in a list ``erase_pos`` to double the repair power. But you can also just specify an empty list.\n\nYou can check how many errors and/or erasures were corrected, which can be useful to design adaptive bitrate algorithms:\n\n.. code:: python\n\nIf the decoding fails, it will normally automatically check and raise a ReedSolomonError exception that you can handle.\nHowever if you want to manually check if the repaired message is correct, you can do so:\n\n.. code:: python",
      "word_count": 499
    },
    {
      "chunk_id": "reedsolo::chunk_2",
      "text": "Note: if you want to use multiple reedsolomon with different parameters, you need to backup the globals and restore them before calling reedsolo functions:\n\n.. code:: python\n\nThen at anytime, you can do:\n\n.. code:: python\n\nThe globals backup is not necessary if you use RSCodec, it will be automatically managed.\n\nRead the sourcecode's comments for more info about how it works, and for the various parameters you can setup if\nyou need to interface with other RS codecs.\n\nExtended description\n--------------------\nThe code of wikiversity is here consolidated into a nice API with exceptions handling.\nThe algorithm can correct up to 2*e+v `_. Then you can simply cd to the root of the folder where creedsolo.pyx is, and type ``python setup.py build_ext --inplace --cythonize``. Alternatively, you can generate just the C++ code by typing `cython -3 creedsolo.pyx`. When building a distributable egg or installing the module from source, the Cython module can be transpiled and compiled if both Cython and a C compiler are installed and the ``--cythonize`` flag is supplied to the setup.py, otherwise by default only the pure-python implementation and the `.pyx` cython source code will be included, but the binary won't be in the wheel.\n\nThen, use `import RSCodec from creedsolo` instead of importing from the `reedsolo` module, and finally only feed `bytearray()` objects to the `RSCodec` object. Exclusively using bytearrays is one of the reasons creedsolo is faster than reedsolo. You can convert any string by specifying the encoding: `bytearray(\"Hello World\", \"UTF-8\")`.\n\nNote that there is an inherent limitation of the C implementation which cannot work with higher galois fields than 8 (= characters of max 255 value) because the C implementation only works with bytearrays, and bytearrays only support characters up to 255. If you want to use higher galois fields, you need to use the pure python version, which includes a fake `_bytearray` function that overloads the standard bytearray in case galois fields higher than 8 are used to `init_tables()`, or rewrite the C implementation to use lists instead of bytearrays (which will be MUCH slower so this defeats the purpose and you are better off simply using the pure python version under PyPy - an older version of the C implementation was doing just that, and without bytearrays, all performance gains were lost, hence why the bytearrays were kept despite the limitations).\n\nEdge cases\n-------------\n\nAlthough sanity checks are implemented whenever possible and when they are not too much resource consuming, there are a few cases where messages will not be decoded correctly without raising an exception:\n\n* If an incorrect erasure location is provided, the decoding algorithm will just trust the provided locations and create a syndrome that will be wrong, resulting in an incorrect decoded message. In case reliability is critical, always use the check() method after decoding to check the decoding did not go wrong.",
      "word_count": 476
    },
    {
      "chunk_id": "reedsolo::chunk_3",
      "text": "* Reed-Solomon algorithm is limited by the Singleton Bound, which limits not only its capacity to correct errors and erasures relatively to the number of error correction symbols, but also its ability to check if the message can be decoded or not. Indeed, if the number of errors and erasures are greater than the Singleton Bound, the decoder has no way to mathematically know for sure whether there is an error at all, it may very well be a valid message (although not the message you expect, but mathematically valid nevertheless). Hence, when the message is tampered beyond the Singleton Bound, the decoder may raise an exception, but it may also return a mathematically valid but still tampered message. Using the check() method cannot fix that either. To work around this issue, a solution is to use parity or hashing functions in parallel to the Reed-Solomon codec: use the Reed-Solomon codec to repair messages, use the parity or hashing function to check if there is any error. Due to how parity and hashing functions work, they are much less likely to produce a false negative than the Reed-Solomon algorithm. This is a general rule: error correction codes are efficient at correcting messages but not at detecting errors, hashing and parity functions are the adequate tool for this purpose.\n\nRecommended reading\n-------------------\n\n* \"`Reed-Solomon codes for coders `_\", free practical beginner's tutorial with Python code examples on WikiVersity. Partially written by one of the authors of the present software.\n* \"Algebraic codes for data transmission\", Blahut, Richard E., 2003, Cambridge university press. `Readable online on Google Books `_. This book was pivotal in helping to understand the intricacies of the universal Berlekamp-Massey algorithm (see figures 7.5 and 7.10).\n\nAuthors\n-------\n\nThis module was conceived and developed by Tomer Filiba in 2012.\n\nIt was further extended and is currently maintained by Stephen Karl Larroque since 2015.\n\nAnd several other contributors helped improve and make it more robust:\n\nContributors\n\nFor a list of all contributors, please see `the GitHub Contributors graph `_ and the `commits history `_.\n\nLicense\n-------\n\nThis software is released under your choice of the Unlicense or the MIT-0 (MIT No Attribution) License. Both licenses are `public-domain-equivalent licenses `_, as intended by the original author Tomer Filiba.\n\n.. |PyPI-Status| image:: https://img.shields.io/pypi/v/reedsolo.svg\n   :target: https://pypi.org/project/reedsolo\n.. |PyPI-Versions| image:: https://img.shields.io/pypi/pyversions/reedsolo.svg?logo=python&logoColor=white\n   :target: https://pypi.org/project/reedsolo\n.. |PyPI-Downloads| image:: https://img.shields.io/pypi/dm/reedsolo.svg?label=pypi%20downloads&logo=python&logoColor=white\n   :target: https://pypi.org/project/reedsolo\n\n:target: https://coveralls.io/github/tomerfiliba/reedsolomon?branch=master\n.. |Conda-Forge-Status| image:: https://img.shields.io/conda/vn/conda-forge/reedsolo.svg\n   :target: https://anaconda.org/conda-forge/reedsolo\n\n:target: https://anaconda.org/conda-forge/reedsolo\n\n:target: https://anaconda.org/conda-forge/reedsolo\n.. |Contributors| image:: https://contrib.rocks/image?repo=tomerfiliba/reedsolomon\n   :target: https://github.com/tomerfiliba/reedsolomon/graphs/contributors",
      "word_count": 413
    }
  ],
  "usage_description": "Here is a 2-sentence summary:\n\nThis library is used to protect data from errors and bitrot in storage mediums, such as hard drives, by encoding and decoding Reed-Solomon codes with support for burst-type errors. It enables developers to implement robust error correction and erasure protection for their data, making it ideal for applications where data integrity is critical."
}