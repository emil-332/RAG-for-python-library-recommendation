{
  "name": "polars-lts-cpu",
  "summary": "Blazingly fast DataFrame library",
  "language": "python",
  "tags": [
    "cli",
    "data",
    "math",
    "ui",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "polars-lts-cpu::chunk_0",
      "text": "Polars: Blazingly fast DataFrames in Rust, Python, Node.js, R, and SQL\n\nPolars is a DataFrame interface on top of an OLAP Query Engine implemented in Rust using\n[Apache Arrow Columnar Format](https://arrow.apache.org/docs/format/Columnar.html) as the memory\nmodel.\n\n- Lazy | eager execution\n- Multi-threaded\n- SIMD\n- Query optimization\n- Powerful expression API\n- Hybrid Streaming (larger-than-RAM datasets)\n- Rust | Python | NodeJS | R | ...\n\nTo learn more, read the [user guide](https://docs.pola.rs/).\n\nPython\n\nSQL\n\nSQL commands can also be run directly from your terminal using the Polars CLI:\n\nRefer to the [Polars CLI repository](https://github.com/pola-rs/polars-cli) for more information.\n\nPerformance\n\nBlazingly fast\n\nPolars is very fast. In fact, it is one of the best performing solutions available. See the\n[PDS-H benchmarks](https://www.pola.rs/benchmarks.html) results.\n\nLightweight\n\nPolars is also very lightweight. It comes with zero required dependencies, and this shows in the\nimport times:\n\n- polars: 70ms\n- numpy: 104ms\n- pandas: 520ms\n\nHandles larger-than-RAM data\n\nIf you have data that does not fit into memory, Polars' query engine is able to process your query\n(or parts of your query) in a streaming fashion. This drastically reduces memory requirements, so\nyou might be able to process your 250GB dataset on your laptop. Collect with\n`collect(engine='streaming')` to run the query streaming. (This might be a little slower, but it is\nstill very fast!)\n\nSetup\n\nPython\n\nInstall the latest Polars version with:\n\nWe also have a conda package (`conda install -c conda-forge polars`), however pip is the preferred\nway to install Polars.\n\nInstall Polars with all optional dependencies.\n\nYou can also install a subset of all optional dependencies.\n\nSee the [User Guide](https://docs.pola.rs/user-guide/installation/#feature-flags) for more details\non optional dependencies\n\nTo see the current Polars version and a full list of its optional dependencies, run:\n\nReleases happen quite often (weekly / every few days) at the moment, so updating Polars regularly to\nget the latest bugfixes / features might not be a bad idea.\n\nRust\n\nYou can take latest release from `crates.io`, or if you want to use the latest features /\nperformance improvements point to the `main` branch of this repo.\n\nRequires Rust version `>=1.80`.\n\nContributing\n\nWant to contribute? Read our [contributing guide](https://docs.pola.rs/development/contributing/).\n\nPython: compile Polars from source\n\nIf you want a bleeding edge release or maximal performance you should compile Polars from source.\n\nThis can be done by going through the following steps in sequence:\n\n1. Install the latest [Rust compiler](https://www.rust-lang.org/tools/install)\n2. Install [maturin](https://maturin.rs/): `pip install maturin`\n3. `cd py-polars` and choose one of the following:\n   - `make build`, slow binary with debug assertions and symbols, fast compile times\n   - `make build-release`, fast binary without debug assertions, minimal debug symbols, long compile\n   - `make build-nodebug-release`, same as build-release but without any debug symbols, slightly\n   - `make build-debug-release`, same as build-release but with full debug symbols, slightly slower\n   - `make build-dist-release`, fastest binary, extreme compile times\n\nBy default the binary is compiled with optimizations turned on for a modern CPU. Specify `LTS_CPU=1`\nwith the command if your CPU is older and does not support e.g. AVX2.\n\nNote that the Rust crate implementing the Python bindings is called `py-polars` to distinguish from\nthe wrapped Rust crate `polars` itself. However, both the Python package and the Python module are\nnamed `polars`, so you can `pip install polars` and `import polars`.\n\nUsing custom Rust functions in Python\n\nExtending Polars with UDFs compiled in Rust is easy. We expose PyO3 extensions for `DataFrame` and\n`Series` data structures. See more in https://github.com/pola-rs/polars/tree/main/pyo3-polars.\n\nGoing big...\n\nDo you expect more than 2^32 (~4.2 billion) rows? Compile Polars with the `bigidx` feature flag or,\nfor Python users, install `pip install polars-u64-idx`.\n\nDon't use this unless you hit the row boundary as the default build of Polars is faster and consumes\nless memory.\n\nLegacy\n\nDo you want Polars to run on an old CPU (e.g. dating from before 2011), or on an `x86-64` build of\nPython on Apple Silicon under Rosetta? Install `pip install polars-lts-cpu`. This version of Polars\nis compiled without [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) target features.\n\nSponsors\n\n[](https://www.jetbrains.com)",
      "word_count": 661
    }
  ],
  "usage_description": "This library is used to create and manage high-performance DataFrames in various programming languages, providing features like lazy execution, multi-threading, and query optimization for efficient data processing. With Polars-LTS-CPU, developers can achieve blazingly fast performance for complex data operations, making it suitable for large-scale data analysis and manipulation tasks."
}