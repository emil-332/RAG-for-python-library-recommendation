{
  "name": "cymem",
  "summary": "Manage calls to calloc/free through Cython",
  "language": "python",
  "tags": [
    "math"
  ],
  "chunks": [
    {
      "chunk_id": "cymem::chunk_0",
      "text": "cymem: A Cython Memory Helper\n\ncymem provides two small memory-management helpers for Cython. They make it easy\nto tie memory to a Python object's life-cycle, so that the memory is freed when\nthe object is garbage collected.\n\n(https://github.com/explosion/cymem/actions/workflows/tests.yml)\n(https://pypi.python.org/pypi/cymem)\n(https://anaconda.org/conda-forge/cymem)\n(https://github.com/explosion/wheelwright/releases)\n\nOverview\n\nThe most useful is `cymem.Pool`, which acts as a thin wrapper around the calloc\nfunction:\n\nThe `Pool` object saves the memory addresses internally, and frees them when the\nobject is garbage collected. Typically you'll attach the `Pool` to some cdef'd\nclass. This is particularly handy for deeply nested structs, which have\ncomplicated initialization functions. Just pass the `Pool` object into the\ninitializer, and you don't have to worry about freeing your struct at all — all\nof the calls to `Pool.alloc` will be automatically freed when the `Pool`\nexpires.\n\nInstallation\n\nInstallation is via [pip](https://pypi.python.org/pypi/pip), and requires\n[Cython](http://cython.org). Before installing, make sure that your `pip`,\n`setuptools` and `wheel` are up to date.\n\nExample Use Case: An array of structs\n\nLet's say we want a sequence of sparse matrices. We need fast access, and a\nPython list isn't performing well enough. So, we want a C-array or C++ vector,\nwhich means we need the sparse matrix to be a C-level struct — it can't be a\nPython class. We can write this easily enough in Cython:\n\nWe wrap the data structure in a Python ref-counted class at as low a level as we\ncan, given our performance constraints. This allows us to allocate and free the\nmemory in the `__cinit__` and `__dealloc__` Cython special methods.\n\nHowever, it's very easy to make mistakes when writing the `__dealloc__` and\n`sparse_matrix_free` functions, leading to memory leaks. cymem prevents you from\nwriting these deallocators at all. Instead, you write as follows:\n\nAll that the `Pool` class does is remember the addresses it gives out. When the\n`MatrixArray` object is garbage-collected, the `Pool` object will also be\ngarbage collected, which triggers a call to `Pool.__dealloc__`. The `Pool` then\nfrees all of its addresses. This saves you from walking back over your nested\ndata structures to free them, eliminating a common class of errors.\n\nCustom Allocators\n\nSometimes external C libraries use private functions to allocate and free\nobjects, but we'd still like the laziness of the `Pool`.\n\nThread Safety\n\nAs of version 2.0.12, `cymem.Pool` is thread-safe when used with CPython 3.13+\nfree-threaded builds (PEP 703). All operations on the Pool, including `alloc()`,\n`free()`, and `realloc()`, can be safely called from multiple threads concurrently.\n\n**Key guarantees:**\n- Multiple threads can safely call `alloc()`, `free()`, and `realloc()` on the\n- The Pool's internal bookkeeping (`addresses` dict and `size` accounting) is\n\n**Important notes:**\n- Individual Pool instances are thread-safe, but you are still responsible for\n- Custom memory allocators need to be thread-safe themselves.",
      "word_count": 455
    }
  ],
  "usage_description": "Here is a 2-sentence summary of what a developer can achieve with this library:\n\nThis library is used to manage memory allocation and deallocation in Cython, allowing developers to tie memory to the life-cycle of Python objects for efficient garbage collection. With cymem, developers can easily handle complex memory management tasks, such as wrapping calloc calls around deeply nested structs, and ensure memory is freed when no longer needed."
}