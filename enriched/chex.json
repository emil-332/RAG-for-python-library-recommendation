{
  "name": "chex",
  "summary": "Chex: Testing made fun, in JAX!",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "ml",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "chex::chunk_0",
      "text": "Chex\n\nChex is a library of utilities for helping to write reliable JAX code.\n\nThis includes utils to help:\n\n* Instrument your code (e.g. assertions, warnings)\n* Debug (e.g. transforming `pmaps` in `vmaps` within a context manager).\n* Test JAX code across many `variants` (e.g. jitted vs non-jitted).\n\nInstallation\n\nYou can install the latest released version of Chex from PyPI via:\n\nor you can install the latest development version from GitHub:\n\nModules Overview\n\nDataclass ([dataclass.py](https://github.com/deepmind/chex/blob/master/chex/_src/dataclass.py))\n\nDataclasses are a popular construct introduced by Python 3.7 to allow to\neasily specify typed data structures with minimal boilerplate code. They are\nnot, however, compatible with JAX and\n[dm-tree](https://github.com/deepmind/tree) out of the box.\n\nIn Chex we provide a JAX-friendly dataclass implementation reusing python [dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses).\n\nChex implementation of `dataclass` registers dataclasses as internal [_PyTree_\nnodes](https://jax.readthedocs.io/en/latest/pytrees.html) to ensure\ncompatibility with JAX data structures.\n\nIn addition, we provide a class wrapper that exposes dataclasses as\n`collections.Mapping` descendants which allows to process them\n(e.g. (un-)flatten) in `dm-tree` methods as usual Python dictionaries.\nSee [`@mappable_dataclass`](https://github.com/deepmind/chex/blob/master/chex/_src/dataclass.py#L27)\ndocstring for more details.\n\nExample:\n\n**NOTE**: Unlike standard Python 3.7 dataclasses, Chex\ndataclasses cannot be constructed using positional arguments. They support\nconstruction arguments provided in the same format as the Python dict\nconstructor. Dataclasses can be converted to tuples with the `from_tuple` and\n`to_tuple` methods if necessary.\n\nAssertions ([asserts.py](https://github.com/deepmind/chex/blob/master/chex/_src/asserts.py))\n\nOne limitation of PyType annotations for JAX is that they do not support the\nspecification of `DeviceArray` ranks, shapes or dtypes. Chex includes a number\nof functions that allow flexible and concise specification of these properties.\n\nE.g. suppose you want to ensure that all tensors `t1`, `t2`, `t3` have the same\nshape, and that tensors `t4`, `t5` have rank `2` and (`3` or `4`), respectively.\n\nMore examples:\n\nSee `asserts.py`\n[documentation](https://chex.readthedocs.io/en/latest/api.html#assertions) to\nfind all supported assertions.\n\nIf you cannot find a specific assertion, please consider making a pull request\nor openning an issue on\n[the bug tracker](https://github.com/deepmind/chex/issues).\n\nOptional Arguments\n\nAll chex assertions support the following optional kwargs for manipulating the\nemitted exception messages:\n\n* `custom_message`: A string to include into the emitted exception messages.\n* `include_default_message`: Whether to include the default Chex message into\n  the emitted exception messages.\n* `exception_type`: An exception type to use. `AssertionError` by default.\n\nFor example, the following code:\n\nwill raise a `ValueError` that includes a step number when `params` get polluted\nwith `NaNs` or `None`s.\n\nStatic and Value (aka *Runtime*) Assertions\n\nChex divides all assertions into 2 classes: ***static*** and ***value***\nassertions.\n\n1.  ***static*** assertions use anything except concrete values of tensors.\n\n2.  ***value*** assertions require access to tensor values, which are not\n\nTo enable value assertions in a jitted function, it can be decorated with\n`chex.chexify()` wrapper. Example:\n\nSee\n[this docstring](https://chex.readthedocs.io/en/latest/api.html#chex.chexify)\nfor more detail on `chex.chexify()`.\n\nJAX Tracing Assertions\n\nJAX re-traces JIT'ted function every time the structure of passed arguments\nchanges. Often this behavior is inadvertent and leads to a significant\nperformance drop which is hard to debug. [@chex.assert_max_traces](https://github.com/deepmind/chex/blob/master/chex/_src/asserts.py#L44)\ndecorator asserts that the function is not re-traced more than `n` times during\nprogram execution.",
      "word_count": 494
    },
    {
      "chunk_id": "chex::chunk_1",
      "text": "Global trace counter can be cleared by calling\n`chex.clear_trace_counter()`. This function be used to isolate unittests relying\non `@chex.assert_max_traces`.\n\nExamples:\n\nCan be used with `jax.pmap()` as well:\n\nSee\n[HowJAX primitives work](https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html)\nsection for more information about tracing.\n\nWarnings ([warnigns.py](https://github.com/deepmind/chex/blob/master/chex/_src/warnings.py))\n\nIn addition to hard assertions Chex also offers utilities to add common\nwarnings, such as specific types of deprecation warnings.\n\nTest variants ([variants.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants.py))\n\nJAX relies extensively on code transformation and compilation, meaning that it\ncan be hard to ensure that code is properly tested. For instance, just testing a\npython function using JAX code will not cover the actual code path that is\nexecuted when jitted, and that path will also differ whether the code is jitted\nfor CPU, GPU, or TPU. This has been a source of obscure and hard to catch bugs\nwhere XLA changes would lead to undesirable behaviours that however only\nmanifest in one specific code transformation.\n\nVariants make it easy to ensure that unit tests cover different ‘variations’ of\na function, by providing a simple decorator that can be used to repeat any test\nunder all (or a subset) of the relevant code transformations.\n\nE.g. suppose you want to test the output of a function `fn` with or without jit.\nYou can use `chex.variants` to run the test with both the jitted and non-jitted\nversion of the function by simply decorating a test method with\n`@chex.variants`, and then using `self.variant(fn)` in place of `fn` in the body\nof the test.\n\nIf you define the function in the test method, you may also use `self.variant`\nas a decorator in the function definition. For example:\n\nExample of parameterized test:\n\nChex currently supports the following variants:\n\n* `with_jit` -- applies `jax.jit()` transformation to the function.\n* `without_jit` -- uses the function as is, i.e. identity transformation.\n* `with_device` -- places all arguments (except specified in `ignore_argnums`\n   argument) into device memory before applying the function.\n* `without_device` -- places all arguments in RAM before applying the function.\n* `with_pmap` -- applies `jax.pmap()` transformation to the function (see notes below).\n\nSee documentation in [variants.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants.py) for more details on the supported variants.\nMore examples can be found in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py).\n\nVariants notes\n\n* Test classes that use `@chex.variants` must inherit from\n`chex.TestCase` (or any other base class that unrolls tests generators\nwithin `TestCase`, e.g. `absl.testing.parameterized.TestCase`).\n\n* **[`jax.vmap`]** All variants can be applied to a vmapped function;\nplease see an example in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py) (`test_vmapped_fn_named_params` and\n`test_pmap_vmapped_fn`).\n\n* **[`@chex.all_variants`]** You can get all supported variants\nby using the decorator `@chex.all_variants`.",
      "word_count": 415
    },
    {
      "chunk_id": "chex::chunk_2",
      "text": "* **[`with_pmap` variant]** `jax.pmap(fn)`\n([doc](https://jax.readthedocs.io/en/latest/jax.html#jax.pmap)) performs\nparallel map of `fn` onto multiple devices. Since most tests run in a\nsingle-device environment (i.e. having access to a single CPU or GPU), in which\ncase `jax.pmap` is a functional equivalent to `jax.jit`, ` with_pmap` variant is\nskipped by default (although it works fine with a single device). Below we\ndescribe  a way to properly test `fn` if it is supposed to be used in\nmulti-device environments (TPUs or multiple CPUs/GPUs). To disable skipping\n`with_pmap` variants in case of a single device, add\n`--chex_skip_pmap_variant_if_single_device=false` to your test command.\n\nFakes ([fake.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake.py))\n\nDebugging in JAX is made more difficult by code transformations such as `jit`\nand `pmap`, which introduce optimizations that make code hard to inspect and\ntrace. It can also be difficult to disable those transformations during\ndebugging as they can be called at several places in the underlying\ncode. Chex provides tools to globally replace `jax.jit` with a no-op\ntransformation and `jax.pmap` with a (non-parallel) `jax.vmap`, in order to more\neasily debug code in a single-device context.\n\nFor example, you can use Chex to fake `pmap` and have it replaced with a `vmap`.\nThis can be achieved by wrapping your code with a context manager:\n\nThe same functionality can also be invoked with `start` and `stop`:\n\nIn addition, you can fake a real multi-device test environment with a\nmulti-threaded CPU. See section **Faking multi-device test environments** for\nmore details.\n\nSee documentation in [fake.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake.py) and examples in [fake_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_test.py) for more details.\n\nFaking multi-device test environments\n\nIn situations where you do not have easy access to multiple devices, you can\nstill test parallel computation using single-device multi-threading.\n\nIn particular, one can force XLA to use a single CPU's threads as separate\ndevices, i.e. to fake a real multi-device environment with a multi-threaded one.\nThese two options are theoretically equivalent from XLA perspective because they\nexpose the same interface and use identical abstractions.\n\nChex has a flag `chex_n_cpu_devices` that specifies a number of CPU threads to\nuse as XLA devices.\n\nTo set up a multi-threaded XLA environment for `absl` tests, define\n`setUpModule` function in your test module:\n\nNow you can launch your test with `python test.py --chex_n_cpu_devices=N` to run\nit in multi-device regime. Note that **all** tests within a module will have an\naccess to `N` devices.\n\nMore examples can be found in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py), [fake_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_test.py) and [fake_set_n_cpu_devices_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_set_n_cpu_devices_test.py).\n\nUsing named dimension sizes.\n\nChex comes with a small utility that allows you to package a collection of\ndimension sizes into a single object. The basic idea is:\n\nString lookups are translated integer tuples. For instance, let's say\n`batch_size == 3`, `sequence_len = 5` and `embedding_dim = 7`, then\n\nYou can also assign dimension sizes dynamically as follows:\n\nFor more examples, see [chex.Dimensions](https://chex.readthedocs.io/en/latest/api.html#chex.Dimensions)\ndocumentation.\n\nCiting Chex\n\nThis repository is part of the [DeepMind JAX Ecosystem], to cite Chex please use\nthe following citation:",
      "word_count": 474
    }
  ],
  "usage_description": "Here is a 2-sentence summary of what a developer can achieve with the Chex library:\n\nThis library is used to simplify the development of reliable and testable code in JAX, providing utilities for instrumentation, debugging, and testing across various variants. With Chex, developers can efficiently write robust and maintainable JAX code by leveraging its suite of tools and utilities."
}