{
  "name": "haversine",
  "summary": "Calculate the distance between 2 points on Earth.",
  "language": "python",
  "tags": [
    "dev",
    "math"
  ],
  "chunks": [
    {
      "chunk_id": "haversine::chunk_0",
      "text": "Haversine\n\nCalculate the distance (in various units) between two points on Earth using their latitude and longitude.\n\nInstallation\n\nUsage\n\nCalculate the distance between Lyon and Paris\n\nThe lat/lon values need to be provided in degrees of the ranges [-90,90] (lat) and [-180,180] (lon).\nIf values are outside their ranges, an error will be raised. This can be avoided by automatic normalization via the `normalize` parameter.\n\nThe `haversine.Unit` enum contains all supported units:\n\noutputs\n\nNote for radians and degrees\n\nThe radian and degrees returns the [great circle distance](https://en.wikipedia.org/wiki/Great-circle_distance) between two points on a sphere.\n\nNotes:\n\n- on a unit-sphere the angular distance in radians equals the distance between the two points on the sphere (definition of radians)\n- When using \"degree\", this angle is just converted from radians to degrees\n\nInverse Haversine Formula\n\nCalculates a point from a given vector (distance and direction) and start point.\nCurrently explicitly supports both cardinal (north, east, south, west) and intercardinal (northeast, southeast, southwest, northwest) directions.\nBut also allows for explicit angles expressed in Radians.\n\nExample: Finding arbitary point from Paris\n\nPerformance optimisation for distances between all points in two vectors\n\nYou will need to install [numpy](https://pypi.org/project/numpy/) in order to gain performance with vectors.\nFor optimal performance, you can turn off coordinate checking by adding `check=False` and install the optional packages [numba](https://pypi.org/project/numba/) and [icc_rt](https://pypi.org/project/icc_rt/).\n\nYou can then do this:\n\nIt is generally slower to use `haversine_vector` to get distance between two points, but can be really fast to compare distances between two vectors.\n\nCombine matrix\n\nYou can generate a matrix of all combinations between coordinates in different vectors by setting `comb` parameter as True.\n\nThe output array from the example above returns the following table:\n\nParis\n------\nLyon\nLondon\n\nBy definition, if you have a vector _a_ with _n_ elements, and a vector _b_ with _m_ elements. The result matrix _M_ would be $n x m$ and a element M\\[i,j\\] from the matrix would be the distance between the ith coordinate from vector _a_ and jth coordinate with vector _b_.\n\nContributing\n\nClone the project.\n\nInstall [pipenv](https://github.com/pypa/pipenv).\n\nRun `pipenv install --dev`\n\nLaunch test with `pipenv run pytest`",
      "word_count": 351
    }
  ],
  "usage_description": "Here is a 2-sentence summary of what a developer can achieve with this library:\n\nThis library is used to calculate the great circle distance, also known as the shortest path along a sphere's surface, between two geographic locations given their latitude and longitude coordinates. With haversine, developers can easily compute distances in various units (e.g., kilometers, miles, etc.) for applications such as navigation, logistics, or mapping services."
}