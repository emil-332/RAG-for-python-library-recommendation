{
  "name": "portion",
  "summary": "Python data structure and operations for intervals",
  "language": "python",
  "tags": [
    "dev",
    "math",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "portion::chunk_0",
      "text": "portion - data structure and operations for intervals\n\n(https://github.com/AlexandreDecan/portion/actions/workflows/test.yaml)\n(https://coveralls.io/github/AlexandreDecan/portion?branch=master)\n(https://github.com/AlexandreDecan/portion/blob/master/LICENSE.txt)\n(https://pypi.org/project/portion)\n(https://github.com/AlexandreDecan/portion/commits/)\n\nThe `portion` library provides data structure and operations for intervals in Python.\n\n- Support intervals of any (comparable) objects.\n - Closed or open, finite or (semi-)infinite intervals.\n - Interval sets (union of atomic intervals) are supported.\n - Automatic simplification of intervals.\n - Support comparison, transformation, intersection, union, complement, difference and containment.\n - Provide test for emptiness, atomicity, overlap and adjacency.\n - Discrete iterations on the values of an interval.\n - Dict-like structure to map intervals to data.\n - Import and export intervals to strings and to Python built-in data types.\n - Heavily tested with high code coverage.\n\nTable of contents\n\n* [Installation](#installation)\n  * [Documentation & usage](#documentation--usage)\n  * [Changelog](#changelog)\n  * [Contributions](#contributions)\n  * [License](#license)\n\nInstallation\n\nYou can use `pip` to install it, as usual: `pip install portion`. This will install the latest available version from [PyPI](https://pypi.org/project/portion).\nPre-releases are available from the *master* branch on [GitHub](https://github.com/AlexandreDecan/portion) and can be installed with `pip install git+https://github.com/AlexandreDecan/portion`.\n\nYou can install `portion` and its development environment using `pip install --group dev` at the root of this repository. This automatically installs [pytest](https://docs.pytest.org/en/latest/) (for the test suites) and [ruff](https://docs.astral.sh/ruff/) (for code style).\n\nDocumentation & usage\n\nInterval creation\n\nAssuming this library is imported using `import portion as P`, intervals can be easily created using one of the following helpers:\n\nThe bounds of an interval can be any arbitrary values, as long as they are comparable:\n\nInfinite and semi-infinite intervals are supported using `P.inf` and `-P.inf` as upper or lower bounds.\nThese two objects support comparison with any other object.\nWhen infinities are used as a lower or upper bound, the corresponding boundary is automatically converted to an open one.\n\nIntervals created with this library are `Interval` instances.\nAn `Interval` instance is a disjunction of atomic intervals each representing a single interval (e.g. `[1,2]`).\nIntervals can be iterated to access the underlying atomic intervals, sorted by their lower and upper bounds.\n\nNested (sorted) intervals can also be retrieved with a position or a slice:\n\nFor convenience, intervals are automatically simplified:\n\nNote that, by default, simplification of discrete intervals is **not** supported by `portion` (but it can be simulated though, see [#24](https://github.com/AlexandreDecan/portion/issues/24#issuecomment-604456362)).\nFor example, combining `[0,1]` with `[2,3]` will **not** result in `[0,3]` even if there is no integer between `1` and `2`.\nRefer to [Specialize & customize intervals](#specialize--customize-intervals) to see how to create and use specialized discrete intervals.\n\n[&uparrow; back to top](#table-of-contents)\n\nInterval bounds & attributes\n\nAn `Interval` defines the following properties:\n\n- `i.empty` is `True` if and only if the interval is empty.\n\n- `i.atomic` is `True` if and only if the interval is empty or is a disjunction of a single interval.\n\n- `i.enclosure` refers to the smallest atomic interval that includes the current one.",
      "word_count": 459
    },
    {
      "chunk_id": "portion::chunk_1",
      "text": "The left and right boundaries, and the lower and upper bounds of an interval can be respectively accessed with its `left`, `right`, `lower` and `upper` attributes.\nThe `left` and `right` bounds are either `P.CLOSED` or `P.OPEN`.\nBy definition, `P.CLOSED == ~P.OPEN` and vice-versa.\n\nBy convention, empty intervals resolve to `(P.inf, -P.inf)`:\n\nIf the interval is not atomic, then `left` and `lower` refer to the lower bound of its enclosure, while `right` and `upper` refer to the upper bound of its enclosure:\n\nOne can easily check for some interval properties based on the bounds of an interval:\n\n[&uparrow; back to top](#table-of-contents)\n\nInterval operations\n\n`Interval` instances support the following operations:\n\n- `i.intersection(other)` and `i & other` return the intersection of two intervals.\n\n- `i.union(other)` and `i | other` return the union of two intervals.\n\n- `i.complement(other)` and `~i` return the complement of the interval.\n\n- `i.difference(other)` and `i - other` return the difference between `i` and `other`.\n\n- `i.contains(other)` and `other in i` hold if given item is contained in the interval.\n It supports intervals and arbitrary comparable values.\n\n- `i.adjacent(other)` tests if the two intervals are adjacent, i.e., if they do not overlap and their union form a single atomic interval.\n While this definition corresponds to the usual notion of adjacency for atomic  intervals, it has stronger requirements for non-atomic ones since it requires  all underlying atomic intervals to be adjacent (i.e. that one  interval fills the gaps between the atomic intervals of the other one).\n\n- `i.overlaps(other)` tests if there is an overlap between two intervals.\n\nFinally, intervals are hashable as long as their bounds are hashable (and we have defined a hash value for `P.inf` and `-P.inf`).\n\n[&uparrow; back to top](#table-of-contents)\n\nComparison operators\n\nEquality between intervals can be checked with the classical `==` operator:\n\nMoreover, intervals are comparable using `>`, `>=`, `>> P.closed(0, 1) >> P.closed(0, 1) >> P.closed(0, 1) >> P.closed(0, 2) >> P.closed(0, 3) >> P.singleton(0) >> P.singleton(0) >> P.singleton(5) >> P.closed(0, 1) ` nor `>=` than any other interval, and no interval is ``, `=` when compared to the empty interval.\n\nMoreover, some non-empty intervals are also not comparable in the classical sense, as illustrated hereafter:\n\nAs a general rule, if `a  a`, `b >= a`, `not (a > b)`, `not (b = b)`, and `not (b >> i = P.closed(0, 2)\n>>> i.replace(P.OPEN, -1, 3, P.CLOSED)\n(-1,3]\n>>> i.replace(lower=1, right=P.OPEN)\n[1,2)\n\npython\n>>> P.closed(0, 2).replace(upper=lambda x: 2 * x)\n[0,4]\n\npython\n>>> i = P.closedopen(0, P.inf)\n>>> i.replace(upper=lambda x: 10)  # No change, infinity is ignored\n[0,+inf)\n>>> i.replace(upper=lambda x: 10, ignore_inf=False)  # Infinity is not ignored\n[0,10)\n\npython\n>>> i = P.openclosed(0, 1) | P.closed(5, 10)\n>>> i.replace(P.CLOSED, -1, 8, P.OPEN)\n[-1,1] | [5,8)\n>>> i.replace(lower=4)\n(4,10]\n\npython\n>>> i = P.closed(2, 3) | P.open(4, 5)\n>>> # Increment bound values\n>>> i.apply(lambda x: (x.left, x.lower + 1, x.upper + 1, x.right))\n[3,4] | (5,6)\n>>> # Invert bounds\n>>> i.apply(lambda x: (~x.left, x.lower, x.upper, ~x.right))\n(2,3) | [4,5]",
      "word_count": 495
    },
    {
      "chunk_id": "portion::chunk_2",
      "text": "python\n>>> i = P.openclosed(-P.inf, 0) | P.closed(3, 4) | P.closedopen(8, P.inf)\n>>> # Increment bound values\n>>> i.apply(lambda x: x.replace(upper=lambda v: v + 1))\n(-inf,1] | [3,5] | [8,+inf)\n>>> # Intervals are still automatically simplified\n>>> i.apply(lambda x: x.replace(lower=lambda v: v * 2))\n(-inf,0] | [16,+inf)\n>>> # Invert bounds\n>>> i.apply(lambda x: x.replace(left=lambda v: ~v, right=lambda v: ~v))\n(-inf,0) | (3,4) | (8,+inf)\n>>> # Replace infinities with -10 and 10\n>>> conv = lambda v: -10 if v == -P.inf else (10 if v == P.inf else v)\n>>> i.apply(lambda x: x.replace(lower=conv, upper=conv, ignore_inf=False))\n(-10,0] | [3,4] | [8,10)\n\npython\n>>> list(P.iterate(P.closed(0, 3), step=1))\n[0, 1, 2, 3]\n>>> list(P.iterate(P.closed(0, 3), step=2))\n[0, 2]\n>>> list(P.iterate(P.open(0, 3), step=2))\n[2]\n\npython\n>>> list(P.iterate(P.singleton(0) | P.singleton(3) | P.singleton(5), step=2))  # Won't be [0]\n[0, 3, 5]\n>>> list(P.iterate(P.closed(0, 2) | P.closed(4, 6), step=3))  # Won't be [0, 6]\n[0, 4]\n\npython\n>>> # Align on integers\n>>> list(P.iterate(P.closed(0.3, 4.9), step=1, base=int))\n[1, 2, 3, 4]\n>>> # Restrict values of a (semi-)infinite interval\n>>> list(P.iterate(P.openclosed(-P.inf, 2), step=1, base=lambda x: max(0, x)))\n[0, 1, 2]\n\npython\n>>> base = lambda x: 0\n>>> list(P.iterate(P.singleton(0) | P.singleton(3) | P.singleton(5), step=2, base=base))\n[0]\n>>> list(P.iterate(P.closed(0, 2) | P.closed(4, 6), step=3, base=base))\n[0, 6]\n\npython\n>>> list(P.iterate(P.closed(0, 3), step=-1, reverse=True))  # Mind step=-1\n[3, 2, 1, 0]\n>>> list(P.iterate(P.closed(0, 3), step=-2, reverse=True))  # Mind step=-2\n[3, 1]\n\npython\n>>> list(P.iterate(P.closed('a', 'd'), step=lambda d: chr(ord(d) + 1)))\n['a', 'b', 'c', 'd']\n>>> # Since we reversed the order, we changed \"+\" to \"-\" in the lambda.\n>>> list(P.iterate(P.closed('a', 'd'), step=lambda d: chr(ord(d) - 1), reverse=True))\n['d', 'c', 'b', 'a']\n\npython\n>>> d = P.IntervalDict()\n>>> d[P.closed(0, 3)] = 'banana'\n>>> d[4] = 'apple'\n>>> d\n{[0,3]: 'banana', [4]: 'apple'}\n\npython\n>>> d[P.closed(2, 4)] = 'orange'\n>>> d\n{[0,2): 'banana', [2,4]: 'orange'}\n\npython\n>>> d[2]\n'orange'\n>>> d[5]  # Key does not exist\nTraceback (most recent call last):\n ...\nKeyError: 5\n>>> d.get(5, default=0)\n0\n\npython\n>>> d[~P.empty()]  # Get all values, similar to d.copy()\n{[0,2): 'banana', [2,4]: 'orange'}\n>>> d[P.closed(1, 3)]\n{[1,2): 'banana', [2,3]: 'orange'}\n>>> d[P.closed(-2, 1)]\n{[0,1]: 'banana'}\n>>> d[P.closed(-2, -1)]\n{}\n\npython\n>>> d.get(P.closed(-2, 1), default='peach')\n{[-2,0): 'peach', [0,1]: 'banana'}\n>>> d.get(P.closed(-2, -1), default='peach')\n{[-2,-1]: 'peach'}\n>>> d.get(P.singleton(1), default='peach')  # Key is covered, default is not used\n{[1]: 'banana'}\n\npython\n>>> d.find('banana')\n[0,2)\n>>> d.find('orange')\n[2,4]\n>>> d.find('carrot')\n()\n\npython\n>>> d.domain()\n[0,4]\n>>> list(d.keys())\n[[0,2), [2,4]]\n>>> list(d.values())\n['banana', 'orange']\n>>> list(d.items())\n[([0,2), 'banana'), ([2,4], 'orange')]\n\npython\n>>> d = P.IntervalDict()\n>>> d[P.closed(0, 1)] = d[P.closed(2, 3)] = 'peach'\n>>> list(d.items())\n[([0,1] | [2,3], 'peach')]\n\npython\n>>> d1 = P.IntervalDict({P.closed(0, 2): 'banana'})\n>>> d2 = P.IntervalDict({P.closed(1, 3): 'orange'})\n>>> concat = lambda x, y: x + '/' + y\n>>> d1.combine(d2, how=concat)\n{[0,1): 'banana', [1,2]: 'banana/orange', (2,3]: 'orange'}\n\npython\n>>> d1.combine(d2, how=concat, missing='kiwi')\n{[0,1): 'banana/kiwi', [1,2]: 'banana/orange', (2,3]: 'kiwi/orange'}",
      "word_count": 480
    },
    {
      "chunk_id": "portion::chunk_3",
      "text": "python\n>>> d = d1.combine(d2, how=concat)\n>>> d[d1.domain()]  # Left join\n{[0,1): 'banana', [1,2]: 'banana/orange'}\n>>> d[d2.domain()]  # Right join\n{[1,2]: 'banana/orange', (2,3]: 'orange'}\n>>> d[d1.domain() & d2.domain()]  # Inner join\n{[1,2]: 'banana/orange'}\n\npython\n>>> P.to_string(P.closedopen(0, 1))\n'[0,1)'\n\npython\n>>> params = {\n...   'disj': ' or ',\n...   'sep': ' - ',\n...   'left_closed': '',\n...   'left_open': '..',\n...   'right_open': '..',\n...   'pinf': '+oo',\n...   'ninf': '-oo',\n...   'conv': lambda v: '\"{}\"'.format(v),\n... }\n>>> x = P.openclosed(0, 1) | P.closed(2, P.inf)\n>>> P.to_string(x, **params)\n'..\"0\" - \"1\"> or >> P.from_string('[0, 1]', conv=int) == P.closed(0, 1)\nTrue\n>>> P.from_string('[1.2]', conv=float) == P.singleton(1.2)\nTrue\n>>> converter = lambda s: datetime.datetime.strptime(s, '%Y/%m/%d')\n>>> P.from_string('[2011/03/15, 2013/10/10]', conv=converter)\n[datetime.datetime(2011, 3, 15, 0, 0),datetime.datetime(2013, 10, 10, 0, 0)]\n\npython\n>>> s = '..\"0\" - \"1\"> or >> params = {\n...   'disj': ' or ',\n...   'sep': ' - ',\n...   'left_closed': '',\n...   'left_open': r'\\.\\.',  # from_string expects regular expression patterns\n...   'right_open': r'\\.\\.',  # from_string expects regular expression patterns\n...   'pinf': r'\\+oo',  # from_string expects regular expression patterns\n...   'ninf': '-oo',\n...   'conv': lambda v: int(v[1:-1]),\n... }\n>>> P.from_string(s, **params)\n(0,1] | [2,+inf)\n\npython\n>>> s = '[(0, 1), (2, 3)]'  # Bounds are expected to be tuples\n>>> P.from_string(s, conv=eval, bound=r'\\(.+?\\)')\n[(0, 1),(2, 3)]\n\npython\n>>> P.to_data(P.openclosed(0, 2))\n[(False, 0, 2, True)]\n\npython\n>>> x = P.openclosed(0, 1) | P.closedopen(2, P.inf)\n>>> P.to_data(x)\n[(False, 0, 1, True), (True, 2, inf, False)]\n\npython\n>>> x = P.closedopen(datetime.date(2011, 3, 15), datetime.date(2013, 10, 10))\n>>> P.to_data(x, conv=lambda v: (v.year, v.month, v.day))\n[(True, (2011, 3, 15), (2013, 10, 10), False)]\n\npython\n>>> x = [(True, (2011, 3, 15), (2013, 10, 10), False)]\n>>> P.from_data(x, conv=lambda v: datetime.date(*v))\n[datetime.date(2011, 3, 15),datetime.date(2013, 10, 10))\n\npython\n>>> P.singleton(0) | P.singleton(1)  # Case 1: should be [0,1] for discrete numbers\n[0] | [1]\n>>> P.open(0, 1)  # Case 2: should be empty\n(0,1)\n>>> P.closedopen(0, 1)  # Case 3: should be singleton [0]\n[0,1)\n\npython\n>>> class IntInterval(P.AbstractDiscreteInterval):\n...     _step = 1\n\npython\n>>> IntInterval.from_atomic(P.CLOSED, 0, 0, P.CLOSED) | IntInterval.from_atomic(P.CLOSED, 1, 1, P.CLOSED)\n[0,1]\n>>> IntInterval.from_atomic(P.OPEN, 0, 1, P.OPEN)\n()\n>>> IntInterval.from_atomic(P.CLOSED, 0, 1, P.OPEN)\n[0]\n\npython\n>>> class CharInterval(P.AbstractDiscreteInterval):\n...     _incr = lambda v: chr(ord(v) + 1)\n...     _decr = lambda v: chr(ord(v) - 1)\n>>> CharInterval.from_atomic(P.OPEN, 'a', 'z', P.OPEN)\n['b','y']\n\npython\n>>> D = P.create_api(IntInterval)\n>>> D.singleton(0) | D.singleton(1)\n[0,1]\n>>> D.open(0, 1)\n()\n>>> D.closedopen(0, 1)\n[0]\n\npython\n>>> class NaturalInterval(IntInterval):\n...    @classmethod\n...    def from_atomic(cls, left, lower, upper, right):\n...        return super().from_atomic(\n...            P.CLOSED if lower >> N = P.create_api(NaturalInterval)\n>>> N.closed(-10, 2)\n[0,2]\n>>> N.open(-10, 2)\n[0,1]\n>>> ~N.empty()\n[0,+inf)\n\npython\n>>> N.closed(1.5, 2.5)  # Bounds are not natural numbers\n[1.5,2.5]\n>>> 0.5 in N.closed(0, 1)  # Given value is not a natural number\nTrue\n>>> ~N.singleton(0.5)\n[1.5,+inf)\n\n@software{portion,\n  author = {Decan, Alexandre},\n  title = {portion: Python data structure and operations for intervals},\n  url = {https://github.com/AlexandreDecan/portion},\n}\n```",
      "word_count": 485
    }
  ],
  "usage_description": "This library is used to efficiently manage and manipulate intervals in Python, allowing developers to represent and perform operations on sets of values with start and end points. With portion, developers can create interval structures that support a wide range of operations, including simplification, comparison, intersection, union, and more."
}