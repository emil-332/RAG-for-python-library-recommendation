{
  "name": "snowflake-sqlalchemy",
  "summary": "Snowflake SQLAlchemy Dialect",
  "language": "python",
  "tags": [
    "data",
    "math",
    "web"
  ],
  "chunks": [
    {
      "chunk_id": "snowflake-sqlalchemy::chunk_0",
      "text": "Snowflake SQLAlchemy\n\n(https://github.com/snowflakedb/snowflake-sqlalchemy/actions/workflows/build_test.yml)\n(https://codecov.io/gh/snowflakedb/snowflake-sqlalchemy)\n(https://pypi.python.org/pypi/snowflake-sqlalchemy/)\n(http://www.apache.org/licenses/LICENSE-2.0.txt)\n(https://github.com/psf/black)\n\nSnowflake SQLAlchemy runs on the top of the Snowflake Connector for Python as a [dialect](http://docs.sqlalchemy.org/en/latest/dialects/) to bridge a Snowflake database and SQLAlchemy applications.\n\nPrerequisites\n\nSnowflake Connector for Python\n\nThe only requirement for Snowflake SQLAlchemy is the Snowflake Connector for Python; however, the connector does not need to be installed because installing Snowflake SQLAlchemy automatically installs the connector.\n\nData Analytics and Web Application Frameworks (Optional)\n\nSnowflake SQLAlchemy can be used with [Pandas](http://pandas.pydata.org/), [Jupyter](http://jupyter.org/) and [Pyramid](http://www.pylonsproject.org/), which provide higher levels of application frameworks for data analytics and web applications. However, building a working environment from scratch is not a trivial task, particularly for novice users. Installing the frameworks requires C compilers and tools, and choosing the right tools and versions is a hurdle that might deter users from using Python applications.\n\nAn easier way to build an environment is through [Anaconda](https://www.continuum.io/why-anaconda), which provides a complete, precompiled technology stack for all users, including non-Python experts such as data analysts and students. For Anaconda installation instructions, see the [Anaconda install documentation](https://docs.continuum.io/anaconda/install). The Snowflake SQLAlchemy package can then be installed on top of Anaconda using [pip](https://pypi.python.org/pypi/pip).\n\nInstalling Snowflake SQLAlchemy\n\nThe Snowflake SQLAlchemy package can be installed from the public PyPI repository using `pip`:\n\n`pip` automatically installs all required modules, including the Snowflake Connector for Python.\n\nVerifying Your Installation\n\n1. Create a file (e.g. `validate.py`) that contains the following Python sample code,\n   which connects to Snowflake and displays the Snowflake version:\n\n2. Replace ``, ``, and `` with the appropriate values for your Snowflake account and user.\n\n3. Execute the sample code. For example, if you created a file named `validate.py`:\n\nParameters and Behavior\n\nAs much as possible, Snowflake SQLAlchemy provides compatible functionality for SQLAlchemy applications. For information on using SQLAlchemy, see the [SQLAlchemy documentation](http://docs.sqlalchemy.org/en/latest/).\n\nHowever, Snowflake SQLAlchemy also provides Snowflake-specific parameters and behavior, which are described in the following sections.\n\nConnection Parameters\n\nSnowflake SQLAlchemy uses the following syntax for the connection string used to connect to Snowflake and initiate a session:\n\nWhere:\n\n- `` is the login name for your Snowflake user.\n- `` is the password for your Snowflake user.\n- `` is the name of your Snowflake account.\n\nInclude the region in the `` if applicable, more info is available [here](https://docs.snowflake.com/en/user-guide/connecting.html#your-snowflake-account-name).\n\nYou can optionally specify the initial database and schema for the Snowflake session by including them at the end of the connection string, separated by `/`. You can also specify the initial warehouse and role for the session as a parameter string at the end of the connection string:\n\nEscaping Special Characters such as `%, @` signs in Passwords\n\nAs pointed out in [SQLAlchemy](https://docs.sqlalchemy.org/en/14/core/engines.html#escaping-special-characters-such-as-signs-in-passwords), URLs\ncontaining special characters need to be URL encoded to be parsed correctly. This includes the `%, @` signs. Unescaped password containing special\ncharacters could lead to authentication failure.\n\nThe encoding for the password can be generated using `urllib.parse`:\n\n**Note**: `urllib.parse.quote_plus` may also be used if there is no space in the string, as `urllib.parse.quote_plus` will replace space with `+`.",
      "word_count": 499
    },
    {
      "chunk_id": "snowflake-sqlalchemy::chunk_1",
      "text": "To create an engine with the proper encodings, either manually constructing the url string by formatting\nor taking advantage of the `snowflake.sqlalchemy.URL` helper method:\n\n**Note**:\nAfter login, the initial database, schema, warehouse and role specified in the connection string can always be changed for the session.\n\nThe following example calls the `create_engine` method with the user name `testuser1`, password `0123456`, account name `abc123`, database `testdb`, schema `public`, warehouse `testwh`, and role `myrole`:\n\nOther parameters, such as `timezone`, can also be specified as a URI parameter or in `connect_args` parameters. For example:\n\nFor convenience, you can use the `snowflake.sqlalchemy.URL` method to construct the connection string and connect to the database. The following example constructs the same connection string from the previous example:\n\nUsing a proxy server\n\nUse the supported environment variables, `HTTPS_PROXY`, `HTTP_PROXY` and `NO_PROXY` to configure a proxy server.\n\nOpening and Closing Connection\n\nOpen a connection by executing `engine.connect()`; avoid using `engine.execute()`. Make certain to close the connection by executing `connection.close()` before\n`engine.dispose()`; otherwise, the Python Garbage collector removes the resources required to communicate with Snowflake, preventing the Python connector from closing the session properly.\n\nAuto-increment Behavior\n\nAuto-incrementing a value requires the `Sequence` object. Include the `Sequence` object in the primary key column to automatically increment the value as each new record is inserted. For example:\n\nObject Name Case Handling\n\nSnowflake stores all case-insensitive object names in uppercase text. In contrast, SQLAlchemy considers all lowercase object names to be case-insensitive. Snowflake SQLAlchemy converts the object name case during schema-level communication, i.e. during table and index reflection. If you use uppercase object names, SQLAlchemy assumes they are case-sensitive and encloses the names with quotes. This behavior will cause mismatches against data dictionary data received from Snowflake, so unless identifier names have been truly created as case sensitive using quotes, e.g., `\"TestDb\"`, all lowercase names should be used on the SQLAlchemy side.\n\nIndex Support\n\nIndexes are supported only for Hybrid Tables in Snowflake SQLAlchemy. For more details on limitations and use cases, refer to the [Create Index documentation](https://docs.snowflake.com/en/sql-reference/constraints-indexes.html). You can create an index using the following methods:\n\nSingle Column Index\n\nYou can create a single column index by setting the `index=True` parameter on the column or by explicitly defining an `Index` object.\n\nMulti-Column Index\n\nFor multi-column indexes, you define the `Index` object specifying the columns that should be indexed.\n\nNumpy Data Type Support\n\nSnowflake SQLAlchemy supports binding and fetching `NumPy` data types. Binding is always supported. To enable fetching `NumPy` data types, add `numpy=True` to the connection parameters.\n\nThe following example shows the round trip of `numpy.datetime64` data:\n\nThe following `NumPy` data types are supported:\n\n- numpy.int64\n- numpy.float64\n- numpy.datatime64\n\nCache Column Metadata\n\nSQLAlchemy provides [the runtime inspection API](http://docs.sqlalchemy.org/en/latest/core/inspection.html) to get the runtime information about the various objects. One of the common use case is get all tables and their column metadata in a schema in order to construct a schema catalog. For example, [alembic](http://alembic.zzzcomputing.com/) on top of SQLAlchemy manages database schema migrations. A pseudo code flow is as follows:",
      "word_count": 499
    },
    {
      "chunk_id": "snowflake-sqlalchemy::chunk_2",
      "text": "In this flow, a potential problem is it may take quite a while as queries run on each table. The results are cached but getting column metadata is expensive.\n\nTo mitigate the problem, Snowflake SQLAlchemy takes a flag `cache_column_metadata=True` such that all of column metadata for all tables are cached when `get_table_names` is called and the rest of `get_columns`, `get_primary_keys` and `get_foreign_keys` can take advantage of the cache.\n\nNote that this flag has been deprecated, as our caching now uses the built-in SQLAlchemy reflection cache, the flag has been removed, but caching has been improved and if possible extra data will be fetched and cached.\n\nVARIANT, ARRAY and OBJECT Support\n\nSnowflake SQLAlchemy supports fetching `VARIANT`, `ARRAY` and `OBJECT` data types. All types are converted into `str` in Python so that you can convert them to native data types using `json.loads`.\n\nThis example shows how to create a table including `VARIANT`, `ARRAY`, and `OBJECT` data type columns.\n\nIn order to retrieve `VARIANT`, `ARRAY`, and `OBJECT` data type columns and convert them to the native Python data types, fetch data and call the `json.loads` method as follows:\n\nStructured Data Types Support\n\nThis module defines custom SQLAlchemy types for Snowflake structured data, specifically for **Iceberg tables**.\nThe types —**MAP**, **OBJECT**, and **ARRAY**— allow you to store complex data structures in your SQLAlchemy models.\nFor detailed information, refer to the Snowflake [Structured data types](https://docs.snowflake.com/en/sql-reference/data-types-structured) documentation.\n\n---\n\nMAP\n\nThe `MAP` type represents a collection of key-value pairs, where each key and value can have different types.\n\n- **Key Type**: The type of the keys (e.g., `TEXT`, `NUMBER`).\n- **Value Type**: The type of the values (e.g., `TEXT`, `NUMBER`).\n- **Not Null**: Whether `NULL` values are allowed (default is `False`).\n\n*Example Usage*\n\nOBJECT\n\nThe `OBJECT` type represents a semi-structured object with named fields. Each field can have a specific type, and you can also specify whether each field is nullable.\n\n- **Items Types**: A dictionary of field names and their types. The type can optionally include a nullable flag (`True` for not nullable, `False` for nullable, default is `False`).\n\n*Example Usage*\n\nARRAY\n\nThe `ARRAY` type represents an ordered list of values, where each element has the same type. The type of the elements is defined when creating the array.\n\n- **Value Type**: The type of the elements in the array (e.g., `TEXT`, `NUMBER`).\n- **Not Null**: Whether `NULL` values are allowed (default is `False`).\n\n*Example Usage*\n\nCLUSTER BY Support\n\nSnowflake SQLAchemy supports the `CLUSTER BY` parameter for tables. For information about the parameter, see :doc:`/sql-reference/sql/create-table`.\n\nThis example shows how to create a table with two columns, `id` and `name`, as the clustering keys:\n\nAlembic Support\n\n[Alembic](http://alembic.zzzcomputing.com) is a database migration tool on top of `SQLAlchemy`. Snowflake SQLAlchemy works by adding the following code to `alembic/env.py` so that Alembic can recognize Snowflake SQLAlchemy.\n\nSee [Alembic Documentation](http://alembic.zzzcomputing.com/) for general usage.\n\nKey Pair Authentication Support",
      "word_count": 476
    },
    {
      "chunk_id": "snowflake-sqlalchemy::chunk_3",
      "text": "Snowflake SQLAlchemy supports key pair authentication by leveraging its Snowflake Connector for Python underpinnings. See [Using Key Pair Authentication](https://docs.snowflake.net/manuals/user-guide/python-connector-example.html#using-key-pair-authentication) for steps to create the private and public keys.\n\nThe private key parameter is passed through `connect_args` as follows:\n\nWhere `PRIVATE_KEY_PASSPHRASE` is a passphrase to decrypt the private key file, `rsa_key.p8`.\n\nCurrently a private key parameter is not accepted by the `snowflake.sqlalchemy.URL` method.\n\nMerge Command Support\n\nSnowflake SQLAlchemy supports upserting with its `MergeInto` custom expression.\nSee [Merge](https://docs.snowflake.net/manuals/sql-reference/sql/merge.html)  for full documentation.\n\nUse it as follows:\n\nCopyIntoStorage Support\n\nSnowflake SQLAlchemy supports saving tables/query results into different stages, as well as into Azure Containers and\nAWS buckets with its custom `CopyIntoStorage` expression. See [Copy into](https://docs.snowflake.net/manuals/sql-reference/sql/copy-into-location.html)\nfor full documentation.\n\nUse it as follows:\n\nIceberg Table with Snowflake Catalog support\n\nSnowflake SQLAlchemy supports Iceberg Tables with the Snowflake Catalog, along with various related parameters. For detailed information about Iceberg Tables, refer to the Snowflake [CREATE ICEBERG](https://docs.snowflake.com/en/sql-reference/sql/create-iceberg-table-snowflake) documentation.\n\nTo create an Iceberg Table using Snowflake SQLAlchemy, you can define the table using the SQLAlchemy Core syntax as follows:\n\nAlternatively, you can define the table using a declarative approach:\n\nHybrid Table support\n\nSnowflake SQLAlchemy supports Hybrid Tables with indexes. For detailed information, refer to the Snowflake [CREATE HYBRID TABLE](https://docs.snowflake.com/en/sql-reference/sql/create-hybrid-table) documentation.\n\nTo create a Hybrid Table and add an index, you can use the SQLAlchemy Core syntax as follows:\n\nAlternatively, you can define the table using the declarative approach:\n\nDynamic Tables support\n\nSnowflake SQLAlchemy supports Dynamic Tables. For detailed information, refer to the Snowflake [CREATE DYNAMIC TABLE](https://docs.snowflake.com/en/sql-reference/sql/create-dynamic-table) documentation.\n\nTo create a Dynamic Table, you can use the SQLAlchemy Core syntax as follows:\n\nAlternatively, you can define a table without columns using the SQLAlchemy `select()` construct:\n\nNotes\n\n- Defining a primary key in a Dynamic Table is not supported, meaning declarative tables don’t support Dynamic Tables.\n- When using the `as_query` parameter with a string, you must explicitly define the columns. However, if you use the SQLAlchemy `select()` construct, you don’t need to explicitly define the columns.\n- Direct data insertion into Dynamic Tables is not supported.\n\nVerifying Package Signatures\n\nTo ensure the authenticity and integrity of the Python package, follow the steps below to verify the package signature using `cosign`.\n\n**Steps to verify the signature:**\n- Install cosign:\n  - This example is using golang installation: [installing-cosign-with-go](https://edu.chainguard.dev/open-source/sigstore/cosign/how-to-install-cosign/#installing-cosign-with-go)\n- Download the file from the repository like pypi:\n  - https://pypi.org/project/snowflake-sqlalchemy/#files\n- Download the signature files from the release tag, replace the version number with the version you are verifying:\n  - https://github.com/snowflakedb/snowflake-sqlalchemy/releases/tag/v1.7.3\n- Verify signature:\n  `\n\nSupport\n\nFeel free to file an issue or submit a PR here for general cases. For official support, contact Snowflake support at:",
      "word_count": 435
    }
  ],
  "usage_description": "This library is used to enable seamless interaction between a Snowflake database and SQLAlchemy applications, allowing developers to leverage the power of both technologies in their projects. With snowflake-sqlalchemy, developers can easily integrate Snowflake databases into their data analytics and web applications using SQLAlchemy's ORM capabilities."
}